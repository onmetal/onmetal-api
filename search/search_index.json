{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OnMetal API Documentation","text":"<p>This page contains the documentation of the onmetal-api project which is part  of the onmetal project.</p>"},{"location":"api-reference/common/","title":"Common","text":"<p>Packages:</p> <ul> <li> common.api.onmetal.de/v1alpha1 </li> </ul>"},{"location":"api-reference/common/#common.api.onmetal.de/v1alpha1","title":"common.api.onmetal.de/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p>"},{"location":"api-reference/common/#common.api.onmetal.de/v1alpha1.ConfigMapKeySelector","title":"ConfigMapKeySelector","text":"<p>ConfigMapKeySelector is a reference to a specific \u2018key\u2019 within a ConfigMap resource. In some instances, <code>key</code> is a required field.</p> Field Description <code>name</code>  string  <p>Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</p> <code>key</code>  string  (Optional) <p>The key of the entry in the ConfigMap resource\u2019s <code>data</code> field to be used. Some instances of this field may be defaulted, in others it may be required.</p>"},{"location":"api-reference/common/#common.api.onmetal.de/v1alpha1.IP","title":"IP","text":"<p> (Appears on:IPRange) </p> <p>IP is an IP address.</p> Field Description <code>-</code>  net/netip.Addr"},{"location":"api-reference/common/#common.api.onmetal.de/v1alpha1.IPPrefix","title":"IPPrefix","text":"<p>IPPrefix represents a network prefix.</p> Field Description <code>-</code>  net/netip.Prefix"},{"location":"api-reference/common/#common.api.onmetal.de/v1alpha1.IPRange","title":"IPRange","text":"<p>IPRange is an IP range.</p> Field Description <code>from</code>  IP  <code>to</code>  IP"},{"location":"api-reference/common/#common.api.onmetal.de/v1alpha1.LocalUIDReference","title":"LocalUIDReference","text":"<p>LocalUIDReference is a reference to another entity including its UID</p> Field Description <code>name</code>  string  <p>Name is the name of the referenced entity.</p> <code>uid</code>  k8s.io/apimachinery/pkg/types.UID  <p>UID is the UID of the referenced entity.</p>"},{"location":"api-reference/common/#common.api.onmetal.de/v1alpha1.SecretKeySelector","title":"SecretKeySelector","text":"<p>SecretKeySelector is a reference to a specific \u2018key\u2019 within a Secret resource. In some instances, <code>key</code> is a required field.</p> Field Description <code>name</code>  string  <p>Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</p> <code>key</code>  string  (Optional) <p>The key of the entry in the Secret resource\u2019s <code>data</code> field to be used. Some instances of this field may be defaulted, in others it may be required.</p>"},{"location":"api-reference/common/#common.api.onmetal.de/v1alpha1.Taint","title":"Taint","text":"<p>The resource pool this Taint is attached to has the \u201ceffect\u201d on any resource that does not tolerate the Taint.</p> Field Description <code>key</code>  string  <p>The taint key to be applied to a resource pool.</p> <code>value</code>  string  <p>The taint value corresponding to the taint key.</p> <code>effect</code>  TaintEffect  <p>The effect of the taint on resources that do not tolerate the taint. Valid effects are NoSchedule, PreferNoSchedule and NoExecute.</p>"},{"location":"api-reference/common/#common.api.onmetal.de/v1alpha1.TaintEffect","title":"TaintEffect (<code>string</code> alias)","text":"<p> (Appears on:Taint, Toleration) </p> Value Description <p>\"NoSchedule\"</p> <p>Do not allow new resources to schedule onto the resource pool unless they tolerate the taint, but allow all already-running resources to continue running. Enforced by the scheduler.</p>"},{"location":"api-reference/common/#common.api.onmetal.de/v1alpha1.Toleration","title":"Toleration","text":"<p>The resource this Toleration is attached to tolerates any taint that matches the triple  using the matching operator . Field Description <code>key</code>  string  <p>Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.</p> <code>operator</code>  TolerationOperator  <p>Operator represents a key\u2019s relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a resource can tolerate all taints of a particular category.</p> <code>value</code>  string  <p>Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.</p> <code>effect</code>  TaintEffect  <p>Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule.</p>"},{"location":"api-reference/common/#common.api.onmetal.de/v1alpha1.TolerationOperator","title":"TolerationOperator (<code>string</code> alias)","text":"<p> (Appears on:Toleration) </p> <p>A toleration operator is the set of operators that can be used in a toleration.</p> Value Description <p>\"Equal\"</p> <p>\"Exists\"</p>"},{"location":"api-reference/common/#common.api.onmetal.de/v1alpha1.UIDReference","title":"UIDReference","text":"<p>UIDReference is a reference to another entity in a potentially different namespace including its UID.</p> Field Description <code>namespace</code>  string  <p>Namespace is the namespace of the referenced entity. If empty, the same namespace as the referring resource is implied.</p> <code>name</code>  string  <p>Name is the name of the referenced entity.</p> <code>uid</code>  k8s.io/apimachinery/pkg/types.UID  <p>UID is the UID of the referenced entity.</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"api-reference/compute/","title":"Compute","text":"<p>Packages:</p> <ul> <li> compute.api.onmetal.de/v1alpha1 </li> </ul>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1","title":"compute.api.onmetal.de/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p> <ul><li> Machine </li><li> MachineClass </li><li> MachinePool </li></ul>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.Machine","title":"Machine","text":"<p>Machine is the Schema for the machines API</p> Field Description <code>apiVersion</code> string <code> compute.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>Machine</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  MachineSpec  <code>machineClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>MachineClassRef is a reference to the machine class/flavor of the machine.</p> <code>machinePoolSelector</code>  map[string]string  <p>MachinePoolSelector selects a suitable MachinePoolRef by the given labels.</p> <code>machinePoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>MachinePoolRef defines machine pool to run the machine in. If empty, a scheduler will figure out an appropriate pool to run the machine in.</p> <code>power</code>  Power  <p>Power is the desired machine power state. Defaults to PowerOn.</p> <code>image</code>  string  (Optional) <p>Image is the optional URL providing the operating system image of the machine.</p> <code>imagePullSecret</code>  Kubernetes core/v1.LocalObjectReference  <p>ImagePullSecretRef is an optional secret for pulling the image of a machine.</p> <code>networkInterfaces</code>  []NetworkInterface  (Optional) <p>NetworkInterfaces define a list of network interfaces present on the machine</p> <code>volumes</code>  []Volume  (Optional) <p>Volumes are volumes attached to this machine.</p> <code>ignitionRef</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.SecretKeySelector  <p>IgnitionRef is a reference to a secret containing the ignition YAML for the machine to boot up. If key is empty, DefaultIgnitionKey will be used as fallback.</p> <code>efiVars</code>  []EFIVar  (Optional) <p>EFIVars are variables to pass to EFI while booting up.</p> <code>tolerations</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Machine has. Only MachinePools whose taints covered by Tolerations will be considered to run the Machine.</p> <code>status</code>  MachineStatus"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachineClass","title":"MachineClass","text":"<p>MachineClass is the Schema for the machineclasses API</p> Field Description <code>apiVersion</code> string <code> compute.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>MachineClass</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>capabilities</code>  github.com/onmetal/onmetal-api/api/core/v1alpha1.ResourceList"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachinePool","title":"MachinePool","text":"<p>MachinePool is the Schema for the machinepools API</p> Field Description <code>apiVersion</code> string <code> compute.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>MachinePool</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  MachinePoolSpec  <code>providerID</code>  string  <p>ProviderID identifies the MachinePool on provider side.</p> <code>taints</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Taint  <p>Taints of the MachinePool. Only Machines who tolerate all the taints will land in the MachinePool.</p> <code>status</code>  MachinePoolStatus"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.DaemonEndpoint","title":"DaemonEndpoint","text":"<p> (Appears on:MachinePoolDaemonEndpoints) </p> <p>DaemonEndpoint contains information about a single Daemon endpoint.</p> Field Description <code>port</code>  int32  <p>Port number of the given endpoint.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.EFIVar","title":"EFIVar","text":"<p> (Appears on:MachineSpec) </p> <p>EFIVar is a variable to pass to EFI while booting up.</p> Field Description <code>name</code>  string  <p>Name is the name of the EFIVar.</p> <code>uuid</code>  string  <p>UUID is the uuid of the EFIVar.</p> <code>value</code>  string  <p>Value is the value of the EFIVar.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.EmptyDiskVolumeSource","title":"EmptyDiskVolumeSource","text":"<p> (Appears on:VolumeSource) </p> <p>EmptyDiskVolumeSource is a volume that\u2019s offered by the machine pool provider. Usually ephemeral (i.e. deleted when the surrounding entity is deleted), with varying performance characteristics. Potentially not recoverable.</p> Field Description <code>sizeLimit</code>  k8s.io/apimachinery/pkg/api/resource.Quantity  <p>SizeLimit is the total amount of local storage required for this EmptyDisk volume. The default is nil which means that the limit is undefined.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.EphemeralNetworkInterfaceSource","title":"EphemeralNetworkInterfaceSource","text":"<p> (Appears on:NetworkInterfaceSource) </p> <p>EphemeralNetworkInterfaceSource is a definition for an ephemeral (i.e. coupled to the lifetime of the surrounding object) networking.NetworkInterface.</p> Field Description <code>networkInterfaceTemplate</code>  github.com/onmetal/onmetal-api/api/networking/v1alpha1.NetworkInterfaceTemplateSpec  <p>NetworkInterfaceTemplate is the template definition of the networking.NetworkInterface.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.EphemeralVolumeSource","title":"EphemeralVolumeSource","text":"<p> (Appears on:VolumeSource) </p> <p>EphemeralVolumeSource is a definition for an ephemeral (i.e. coupled to the lifetime of the surrounding object) storage.Volume.</p> Field Description <code>volumeTemplate</code>  github.com/onmetal/onmetal-api/api/storage/v1alpha1.VolumeTemplateSpec  <p>VolumeTemplate is the template definition of the storage.Volume.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachineExecOptions","title":"MachineExecOptions","text":"<p>MachineExecOptions is the query options to a Machine\u2019s remote exec call</p> Field Description <code>insecureSkipTLSVerifyBackend</code>  bool"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachinePoolAddress","title":"MachinePoolAddress","text":"<p> (Appears on:MachinePoolStatus) </p> Field Description <code>type</code>  MachinePoolAddressType  <code>address</code>  string"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachinePoolAddressType","title":"MachinePoolAddressType (<code>string</code> alias)","text":"<p> (Appears on:MachinePoolAddress) </p> Value Description <p>\"ExternalDNS\"</p> <p>MachinePoolExternalDNS identifies a DNS name which resolves to an IP address which has the characteristics of MachinePoolExternalIP. The IP it resolves to may or may not be a listed MachineExternalIP address.</p> <p>\"ExternalIP\"</p> <p>MachinePoolExternalIP identifies an IP address which is, in some way, intended to be more usable from outside the cluster than an internal IP, though no specific semantics are defined.</p> <p>\"Hostname\"</p> <p>MachinePoolHostName identifies a name of the machine pool. Although every machine pool can be assumed to have a MachinePoolAddress of this type, its exact syntax and semantics are not defined, and are not consistent between different clusters.</p> <p>\"InternalDNS\"</p> <p>MachinePoolInternalDNS identifies a DNS name which resolves to an IP address which has the characteristics of a MachinePoolInternalIP. The IP it resolves to may or may not be a listed MachinePoolInternalIP address.</p> <p>\"InternalIP\"</p> <p>MachinePoolInternalIP identifies an IP address which may not be visible to hosts outside the cluster. By default, it is assumed that onmetal-api-apiserver can reach machine pool internal IPs, though it is possible to configure clusters where this is not the case.</p> <p>MachinePoolInternalIP is the default type of machine pool IP, and does not necessarily imply that the IP is ONLY reachable internally. If a machine pool has multiple internal IPs, no specific semantics are assigned to the additional IPs.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachinePoolCondition","title":"MachinePoolCondition","text":"<p> (Appears on:MachinePoolStatus) </p> <p>MachinePoolCondition is one of the conditions of a volume.</p> Field Description <code>type</code>  MachinePoolConditionType  <p>Type is the type of the condition.</p> <code>status</code>  Kubernetes core/v1.ConditionStatus  <p>Status is the status of the condition.</p> <code>reason</code>  string  <p>Reason is a machine-readable indication of why the condition is in a certain state.</p> <code>message</code>  string  <p>Message is a human-readable explanation of why the condition has a certain reason / state.</p> <code>observedGeneration</code>  int64  <p>ObservedGeneration represents the .metadata.generation that the condition was set based upon.</p> <code>lastTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastTransitionTime is the last time the status of a condition has transitioned from one state to another.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachinePoolConditionType","title":"MachinePoolConditionType (<code>string</code> alias)","text":"<p> (Appears on:MachinePoolCondition) </p> <p>MachinePoolConditionType is a type a MachinePoolCondition can have.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachinePoolDaemonEndpoints","title":"MachinePoolDaemonEndpoints","text":"<p> (Appears on:MachinePoolStatus) </p> <p>MachinePoolDaemonEndpoints lists ports opened by daemons running on the MachinePool.</p> Field Description <code>machinepoolletEndpoint</code>  DaemonEndpoint  (Optional) <p>Endpoint on which machinepoollet is listening.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachinePoolSpec","title":"MachinePoolSpec","text":"<p> (Appears on:MachinePool) </p> <p>MachinePoolSpec defines the desired state of MachinePool</p> Field Description <code>providerID</code>  string  <p>ProviderID identifies the MachinePool on provider side.</p> <code>taints</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Taint  <p>Taints of the MachinePool. Only Machines who tolerate all the taints will land in the MachinePool.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachinePoolState","title":"MachinePoolState (<code>string</code> alias)","text":"<p> (Appears on:MachinePoolStatus) </p> <p>MachinePoolState is a state a MachinePool can be in.</p> Value Description <p>\"Error\"</p> <p>MachinePoolStateError marks a MachinePool in an error state.</p> <p>\"Offline\"</p> <p>MachinePoolStateOffline marks a MachinePool as offline.</p> <p>\"Pending\"</p> <p>MachinePoolStatePending marks a MachinePool as pending readiness.</p> <p>\"Ready\"</p> <p>MachinePoolStateReady marks a MachinePool as ready for accepting a Machine.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachinePoolStatus","title":"MachinePoolStatus","text":"<p> (Appears on:MachinePool) </p> <p>MachinePoolStatus defines the observed state of MachinePool</p> Field Description <code>state</code>  MachinePoolState  <code>conditions</code>  []MachinePoolCondition  <code>availableMachineClasses</code>  []Kubernetes core/v1.LocalObjectReference  <code>addresses</code>  []MachinePoolAddress  <code>daemonEndpoints</code>  MachinePoolDaemonEndpoints  <code>capacity</code>  github.com/onmetal/onmetal-api/api/core/v1alpha1.ResourceList  <p>Capacity represents the total resources of a machine pool.</p> <code>allocatable</code>  github.com/onmetal/onmetal-api/api/core/v1alpha1.ResourceList  <p>Allocatable represents the resources of a machine pool that are available for scheduling.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachineSpec","title":"MachineSpec","text":"<p> (Appears on:Machine) </p> <p>MachineSpec defines the desired state of Machine</p> Field Description <code>machineClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>MachineClassRef is a reference to the machine class/flavor of the machine.</p> <code>machinePoolSelector</code>  map[string]string  <p>MachinePoolSelector selects a suitable MachinePoolRef by the given labels.</p> <code>machinePoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>MachinePoolRef defines machine pool to run the machine in. If empty, a scheduler will figure out an appropriate pool to run the machine in.</p> <code>power</code>  Power  <p>Power is the desired machine power state. Defaults to PowerOn.</p> <code>image</code>  string  (Optional) <p>Image is the optional URL providing the operating system image of the machine.</p> <code>imagePullSecret</code>  Kubernetes core/v1.LocalObjectReference  <p>ImagePullSecretRef is an optional secret for pulling the image of a machine.</p> <code>networkInterfaces</code>  []NetworkInterface  (Optional) <p>NetworkInterfaces define a list of network interfaces present on the machine</p> <code>volumes</code>  []Volume  (Optional) <p>Volumes are volumes attached to this machine.</p> <code>ignitionRef</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.SecretKeySelector  <p>IgnitionRef is a reference to a secret containing the ignition YAML for the machine to boot up. If key is empty, DefaultIgnitionKey will be used as fallback.</p> <code>efiVars</code>  []EFIVar  (Optional) <p>EFIVars are variables to pass to EFI while booting up.</p> <code>tolerations</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Machine has. Only MachinePools whose taints covered by Tolerations will be considered to run the Machine.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachineState","title":"MachineState (<code>string</code> alias)","text":"<p> (Appears on:MachineStatus) </p> <p>MachineState is the state of a machine.</p> Value Description <p>\"Pending\"</p> <p>MachineStatePending means the Machine has been accepted by the system, but not yet completely started. This includes time before being bound to a MachinePool, as well as time spent setting up the Machine on that MachinePool.</p> <p>\"Running\"</p> <p>MachineStateRunning means the machine is running on a MachinePool.</p> <p>\"Shutdown\"</p> <p>MachineStateShutdown means the machine is shut down.</p> <p>\"Terminated\"</p> <p>MachineStateTerminated means the machine has been permanently stopped and cannot be started.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.MachineStatus","title":"MachineStatus","text":"<p> (Appears on:Machine) </p> <p>MachineStatus defines the observed state of Machine</p> Field Description <code>machineID</code>  string  <p>MachineID is the provider specific machine ID in the format \u2018://\u2019. <code>observedGeneration</code>  int64  <p>ObservedGeneration is the last generation the MachinePool observed of the Machine.</p> <code>state</code>  MachineState  <p>State is the infrastructure state of the machine.</p> <code>networkInterfaces</code>  []NetworkInterfaceStatus  <p>NetworkInterfaces is the list of network interface states for the machine.</p> <code>volumes</code>  []VolumeStatus  <p>Volumes is the list of volume states for the machine.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.NetworkInterface","title":"NetworkInterface","text":"<p> (Appears on:MachineSpec) </p> <p>NetworkInterface is the definition of a single interface</p> Field Description <code>name</code>  string  <p>Name is the name of the network interface.</p> <code>NetworkInterfaceSource</code>  NetworkInterfaceSource  <p> (Members of <code>NetworkInterfaceSource</code> are embedded into this type.) </p> <p>NetworkInterfaceSource is where to obtain the interface from.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.NetworkInterfaceSource","title":"NetworkInterfaceSource","text":"<p> (Appears on:NetworkInterface) </p> Field Description <code>networkInterfaceRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkInterfaceRef instructs to use the NetworkInterface at the target reference.</p> <code>ephemeral</code>  EphemeralNetworkInterfaceSource  <p>Ephemeral instructs to create an ephemeral (i.e. coupled to the lifetime of the surrounding object) NetworkInterface to use.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.NetworkInterfaceState","title":"NetworkInterfaceState (<code>string</code> alias)","text":"<p> (Appears on:NetworkInterfaceStatus) </p> <p>NetworkInterfaceState is the infrastructure attachment state a NetworkInterface can be in.</p> Value Description <p>\"Attached\"</p> <p>NetworkInterfaceStateAttached indicates that a network interface has been successfully attached.</p> <p>\"Pending\"</p> <p>NetworkInterfaceStatePending indicates that the attachment of a network interface is pending.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.NetworkInterfaceStatus","title":"NetworkInterfaceStatus","text":"<p> (Appears on:MachineStatus) </p> <p>NetworkInterfaceStatus reports the status of an NetworkInterfaceSource.</p> Field Description <code>name</code>  string  <p>Name is the name of the NetworkInterface to whom the status belongs to.</p> <code>handle</code>  string  <p>Handle is the MachinePool internal handle of the NetworkInterface.</p> <code>ips</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.IP  <p>IPs are the ips allocated for the network interface.</p> <code>virtualIP</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IP  <p>VirtualIP is the virtual ip allocated for the network interface.</p> <code>state</code>  NetworkInterfaceState  <p>State represents the attachment state of a NetworkInterface.</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.Power","title":"Power (<code>string</code> alias)","text":"<p> (Appears on:MachineSpec) </p> <p>Power is the desired power state of a Machine.</p> Value Description <p>\"Off\"</p> <p>PowerOff indicates that a Machine should be powered off.</p> <p>\"On\"</p> <p>PowerOn indicates that a Machine should be powered on.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.Volume","title":"Volume","text":"<p> (Appears on:MachineSpec) </p> <p>Volume defines a volume attachment of a machine</p> Field Description <code>name</code>  string  <p>Name is the name of the Volume</p> <code>device</code>  string  <p>Device is the device name where the volume should be attached. Pointer to distinguish between explicit zero and not specified. If empty, an unused device name will be determined if possible.</p> <code>VolumeSource</code>  VolumeSource  <p> (Members of <code>VolumeSource</code> are embedded into this type.) </p> <p>VolumeSource is the source where the storage for the Volume resides at.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.VolumeSource","title":"VolumeSource","text":"<p> (Appears on:Volume) </p> <p>VolumeSource specifies the source to use for a Volume.</p> Field Description <code>volumeRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumeRef instructs to use the specified Volume as source for the attachment.</p> <code>emptyDisk</code>  EmptyDiskVolumeSource  <p>EmptyDisk instructs to use a Volume offered by the machine pool provider.</p> <code>ephemeral</code>  EphemeralVolumeSource  <p>Ephemeral instructs to create an ephemeral (i.e. coupled to the lifetime of the surrounding object) Volume to use.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.VolumeState","title":"VolumeState (<code>string</code> alias)","text":"<p> (Appears on:VolumeStatus) </p> <p>VolumeState is the infrastructure attachment state a Volume can be in.</p> Value Description <p>\"Attached\"</p> <p>VolumeStateAttached indicates that a volume has been successfully attached.</p> <p>\"Pending\"</p> <p>VolumeStatePending indicates that the attachment of a volume is pending.</p>"},{"location":"api-reference/compute/#compute.api.onmetal.de/v1alpha1.VolumeStatus","title":"VolumeStatus","text":"<p> (Appears on:MachineStatus) </p> <p>VolumeStatus is the status of a Volume.</p> Field Description <code>name</code>  string  <p>Name is the name of a volume attachment.</p> <code>handle</code>  string  <p>Handle is the MachinePool internal handle of the volume.</p> <code>state</code>  VolumeState  <p>State represents the attachment state of a Volume.</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned.</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"api-reference/core/","title":"Core","text":"<p>Packages:</p> <ul> <li> core.api.onmetal.de/v1alpha1 </li> </ul>"},{"location":"api-reference/core/#core.api.onmetal.de/v1alpha1","title":"core.api.onmetal.de/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p> <ul><li> ResourceQuota </li></ul>"},{"location":"api-reference/core/#core.api.onmetal.de/v1alpha1.ResourceQuota","title":"ResourceQuota","text":"<p>ResourceQuota is the Schema for the resourcequotas API</p> Field Description <code>apiVersion</code> string <code> core.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>ResourceQuota</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  ResourceQuotaSpec  <code>hard</code>  ResourceList  <p>Hard is a ResourceList of the strictly enforced amount of resources.</p> <code>scopeSelector</code>  ResourceScopeSelector  <p>ScopeSelector selects the resources that are subject to this quota. Note: By using certain ScopeSelectors, only certain resources may be tracked.</p> <code>status</code>  ResourceQuotaStatus"},{"location":"api-reference/core/#core.api.onmetal.de/v1alpha1.ClassType","title":"ClassType (<code>string</code> alias)","text":"Value Description <p>\"machine\"</p> <p>\"volume\"</p>"},{"location":"api-reference/core/#core.api.onmetal.de/v1alpha1.ObjectSelector","title":"ObjectSelector","text":"<p>ObjectSelector specifies how to select objects of a certain kind.</p> Field Description <code>kind</code>  string  <p>Kind is the kind of object to select.</p> <code>LabelSelector</code>  Kubernetes meta/v1.LabelSelector  <p> (Members of <code>LabelSelector</code> are embedded into this type.) </p> <p>LabelSelector is the label selector to select objects of the specified Kind by.</p>"},{"location":"api-reference/core/#core.api.onmetal.de/v1alpha1.ResourceName","title":"ResourceName (<code>string</code> alias)","text":"<p>ResourceName is the name of a resource, most often used alongside a resource.Quantity.</p> Value Description <p>\"cpu\"</p> <p>ResourceCPU is the amount of cpu in cores.</p> <p>\"iops\"</p> <p>ResourceIOPS defines max IOPS in input/output operations per second.</p> <p>\"memory\"</p> <p>ResourceMemory is the amount of memory in bytes.</p> <p>\"requests.cpu\"</p> <p>ResourceRequestsCPU is the amount of requested cpu in cores.</p> <p>\"requests.memory\"</p> <p>ResourceRequestsMemory is the amount of requested memory in bytes.</p> <p>\"requests.storage\"</p> <p>ResourceRequestsStorage is the amount of requested storage in bytes.</p> <p>\"storage\"</p> <p>ResourceStorage is the amount of storage, in bytes.</p> <p>\"tps\"</p> <p>ResourceTPS defines max throughput per second. (e.g. 1Gi)</p>"},{"location":"api-reference/core/#core.api.onmetal.de/v1alpha1.ResourceQuotaSpec","title":"ResourceQuotaSpec","text":"<p> (Appears on:ResourceQuota) </p> <p>ResourceQuotaSpec defines the desired state of ResourceQuotaSpec</p> Field Description <code>hard</code>  ResourceList  <p>Hard is a ResourceList of the strictly enforced amount of resources.</p> <code>scopeSelector</code>  ResourceScopeSelector  <p>ScopeSelector selects the resources that are subject to this quota. Note: By using certain ScopeSelectors, only certain resources may be tracked.</p>"},{"location":"api-reference/core/#core.api.onmetal.de/v1alpha1.ResourceQuotaStatus","title":"ResourceQuotaStatus","text":"<p> (Appears on:ResourceQuota) </p> <p>ResourceQuotaStatus is the status of a ResourceQuota.</p> Field Description <code>hard</code>  ResourceList  <p>Hard are the currently enforced hard resource limits. Hard may be less than used in case the limits were introduced / updated after more than allowed resources were already present.</p> <code>used</code>  ResourceList  <p>Used is the amount of currently used resources.</p>"},{"location":"api-reference/core/#core.api.onmetal.de/v1alpha1.ResourceScope","title":"ResourceScope (<code>string</code> alias)","text":"<p> (Appears on:ResourceScopeSelectorRequirement) </p> <p>ResourceScope is a scope of a resource.</p> Value Description <p>\"BucketClass\"</p> <p>ResourceScopeBucketClass refers to the bucket class of a resource.</p> <p>\"MachineClass\"</p> <p>ResourceScopeMachineClass refers to the machine class of a resource.</p> <p>\"VolumeClass\"</p> <p>ResourceScopeVolumeClass refers to the volume class of a resource.</p>"},{"location":"api-reference/core/#core.api.onmetal.de/v1alpha1.ResourceScopeSelector","title":"ResourceScopeSelector","text":"<p> (Appears on:ResourceQuotaSpec) </p> <p>ResourceScopeSelector selects</p> Field Description <code>matchExpressions</code>  []ResourceScopeSelectorRequirement  <p>MatchExpressions is a list of ResourceScopeSelectorRequirement to match resources by.</p>"},{"location":"api-reference/core/#core.api.onmetal.de/v1alpha1.ResourceScopeSelectorOperator","title":"ResourceScopeSelectorOperator (<code>string</code> alias)","text":"<p> (Appears on:ResourceScopeSelectorRequirement) </p> <p>ResourceScopeSelectorOperator is an operator to compare a ResourceScope with values.</p> Value Description <p>\"DoesNotExist\"</p> <p>\"Exists\"</p> <p>\"In\"</p> <p>\"NotIn\"</p>"},{"location":"api-reference/core/#core.api.onmetal.de/v1alpha1.ResourceScopeSelectorRequirement","title":"ResourceScopeSelectorRequirement","text":"<p> (Appears on:ResourceScopeSelector) </p> <p>ResourceScopeSelectorRequirement is a requirement for a resource using a ResourceScope alongside a ResourceScopeSelectorOperator with Values (depending on the ResourceScopeSelectorOperator).</p> Field Description <code>scopeName</code>  ResourceScope  <p>ScopeName is the ResourceScope to make a requirement for.</p> <code>operator</code>  ResourceScopeSelectorOperator  <p>Operator is the ResourceScopeSelectorOperator to check the ScopeName with in a resource.</p> <code>values</code>  []string  <p>Values are the values to compare the Operator with the ScopeName. May be optional.</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"api-reference/ipam/","title":"IPAM","text":"<p>Packages:</p> <ul> <li> ipam.api.onmetal.de/v1alpha1 </li> </ul>"},{"location":"api-reference/ipam/#ipam.api.onmetal.de/v1alpha1","title":"ipam.api.onmetal.de/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p> <ul><li> Prefix </li><li> PrefixAllocation </li></ul>"},{"location":"api-reference/ipam/#ipam.api.onmetal.de/v1alpha1.Prefix","title":"Prefix","text":"<p>Prefix is the Schema for the prefixes API</p> Field Description <code>apiVersion</code> string <code> ipam.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>Prefix</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  PrefixSpec  <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the IPFamily of the prefix. If unset but Prefix is set, this can be inferred.</p> <code>prefix</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IPPrefix  <p>Prefix is the prefix to allocate for this Prefix.</p> <code>prefixLength</code>  int32  <p>PrefixLength is the length of prefix to allocate for this Prefix.</p> <code>parentRef</code>  Kubernetes core/v1.LocalObjectReference  <p>ParentRef references the parent to allocate the Prefix from. If ParentRef and ParentSelector is empty, the Prefix is considered a root prefix and thus allocated by itself.</p> <code>parentSelector</code>  Kubernetes meta/v1.LabelSelector  <p>ParentSelector is the LabelSelector to use for determining the parent for this Prefix.</p> <code>status</code>  PrefixStatus"},{"location":"api-reference/ipam/#ipam.api.onmetal.de/v1alpha1.PrefixAllocation","title":"PrefixAllocation","text":"<p>PrefixAllocation is the Schema for the prefixallocations API</p> Field Description <code>apiVersion</code> string <code> ipam.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>PrefixAllocation</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  PrefixAllocationSpec  <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the IPFamily of the prefix. If unset but Prefix is set, this can be inferred.</p> <code>prefix</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IPPrefix  <p>Prefix is the prefix to allocate for this Prefix.</p> <code>prefixLength</code>  int32  <p>PrefixLength is the length of prefix to allocate for this Prefix.</p> <code>prefixRef</code>  Kubernetes core/v1.LocalObjectReference  <p>PrefixRef references the prefix to allocate from.</p> <code>prefixSelector</code>  Kubernetes meta/v1.LabelSelector  <p>PrefixSelector selects the prefix to allocate from.</p> <code>status</code>  PrefixAllocationStatus"},{"location":"api-reference/ipam/#ipam.api.onmetal.de/v1alpha1.PrefixAllocationPhase","title":"PrefixAllocationPhase (<code>string</code> alias)","text":"<p> (Appears on:PrefixAllocationStatus) </p> <p>PrefixAllocationPhase is a phase a PrefixAllocation can be in.</p> Value Description <p>\"Allocated\"</p> <p>PrefixAllocationPhaseAllocated marks a PrefixAllocation as allocated by a Prefix.</p> <p>\"Failed\"</p> <p>PrefixAllocationPhaseFailed marks a PrefixAllocation as failed.</p> <p>\"Pending\"</p> <p>PrefixAllocationPhasePending marks a PrefixAllocation as waiting for allocation.</p>"},{"location":"api-reference/ipam/#ipam.api.onmetal.de/v1alpha1.PrefixAllocationSpec","title":"PrefixAllocationSpec","text":"<p> (Appears on:PrefixAllocation) </p> <p>PrefixAllocationSpec defines the desired state of PrefixAllocation</p> Field Description <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the IPFamily of the prefix. If unset but Prefix is set, this can be inferred.</p> <code>prefix</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IPPrefix  <p>Prefix is the prefix to allocate for this Prefix.</p> <code>prefixLength</code>  int32  <p>PrefixLength is the length of prefix to allocate for this Prefix.</p> <code>prefixRef</code>  Kubernetes core/v1.LocalObjectReference  <p>PrefixRef references the prefix to allocate from.</p> <code>prefixSelector</code>  Kubernetes meta/v1.LabelSelector  <p>PrefixSelector selects the prefix to allocate from.</p>"},{"location":"api-reference/ipam/#ipam.api.onmetal.de/v1alpha1.PrefixAllocationStatus","title":"PrefixAllocationStatus","text":"<p> (Appears on:PrefixAllocation) </p> <p>PrefixAllocationStatus is the status of a PrefixAllocation.</p> Field Description <code>prefix</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IPPrefix  <p>Prefix is the allocated prefix, if any</p> <code>phase</code>  PrefixAllocationPhase  <p>Phase is the phase of the PrefixAllocation.</p> <code>lastPhaseTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastPhaseTransitionTime is the last time the Phase changed values.</p>"},{"location":"api-reference/ipam/#ipam.api.onmetal.de/v1alpha1.PrefixPhase","title":"PrefixPhase (<code>string</code> alias)","text":"<p> (Appears on:PrefixStatus) </p> <p>PrefixPhase is a phase a Prefix can be in.</p> Value Description <p>\"Allocated\"</p> <p>PrefixPhaseAllocated marks a prefix as allocated.</p> <p>\"Pending\"</p> <p>PrefixPhasePending marks a prefix as waiting for allocation.</p>"},{"location":"api-reference/ipam/#ipam.api.onmetal.de/v1alpha1.PrefixSpec","title":"PrefixSpec","text":"<p> (Appears on:Prefix, PrefixTemplateSpec) </p> <p>PrefixSpec defines the desired state of Prefix</p> Field Description <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the IPFamily of the prefix. If unset but Prefix is set, this can be inferred.</p> <code>prefix</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IPPrefix  <p>Prefix is the prefix to allocate for this Prefix.</p> <code>prefixLength</code>  int32  <p>PrefixLength is the length of prefix to allocate for this Prefix.</p> <code>parentRef</code>  Kubernetes core/v1.LocalObjectReference  <p>ParentRef references the parent to allocate the Prefix from. If ParentRef and ParentSelector is empty, the Prefix is considered a root prefix and thus allocated by itself.</p> <code>parentSelector</code>  Kubernetes meta/v1.LabelSelector  <p>ParentSelector is the LabelSelector to use for determining the parent for this Prefix.</p>"},{"location":"api-reference/ipam/#ipam.api.onmetal.de/v1alpha1.PrefixStatus","title":"PrefixStatus","text":"<p> (Appears on:Prefix) </p> <p>PrefixStatus defines the observed state of Prefix</p> Field Description <code>phase</code>  PrefixPhase  <p>Phase is the PrefixPhase of the Prefix.</p> <code>lastPhaseTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastPhaseTransitionTime is the last time the Phase changed values.</p> <code>used</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.IPPrefix  <p>Used is a list of used prefixes.</p>"},{"location":"api-reference/ipam/#ipam.api.onmetal.de/v1alpha1.PrefixTemplateSpec","title":"PrefixTemplateSpec","text":"Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  PrefixSpec  <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the IPFamily of the prefix. If unset but Prefix is set, this can be inferred.</p> <code>prefix</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IPPrefix  <p>Prefix is the prefix to allocate for this Prefix.</p> <code>prefixLength</code>  int32  <p>PrefixLength is the length of prefix to allocate for this Prefix.</p> <code>parentRef</code>  Kubernetes core/v1.LocalObjectReference  <p>ParentRef references the parent to allocate the Prefix from. If ParentRef and ParentSelector is empty, the Prefix is considered a root prefix and thus allocated by itself.</p> <code>parentSelector</code>  Kubernetes meta/v1.LabelSelector  <p>ParentSelector is the LabelSelector to use for determining the parent for this Prefix.</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"api-reference/networking/","title":"Networking","text":"<p>Packages:</p> <ul> <li> networking.api.onmetal.de/v1alpha1 </li> </ul>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1","title":"networking.api.onmetal.de/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p> <ul><li> LoadBalancer </li><li> LoadBalancerRouting </li><li> NATGateway </li><li> Network </li><li> NetworkInterface </li><li> NetworkPolicy </li><li> VirtualIP </li></ul>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.LoadBalancer","title":"LoadBalancer","text":"<p>LoadBalancer is the Schema for the LoadBalancer API</p> Field Description <code>apiVersion</code> string <code> networking.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>LoadBalancer</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  LoadBalancerSpec  <code>type</code>  LoadBalancerType  <p>Type is the type of LoadBalancer.</p> <code>ipFamilies</code>  []Kubernetes core/v1.IPFamily  <p>IPFamilies are the ip families the load balancer should have.</p> <code>ips</code>  []IPSource  <p>IPs are the ips to use. Can only be used when Type is LoadBalancerTypeInternal.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this LoadBalancer should belong to.</p> <code>networkInterfaceSelector</code>  Kubernetes meta/v1.LabelSelector  <p>NetworkInterfaceSelector defines the NetworkInterfaces for which this LoadBalancer should be applied</p> <code>ports</code>  []LoadBalancerPort  <p>Ports are the ports the load balancer should allow.</p> <code>status</code>  LoadBalancerStatus"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.LoadBalancerRouting","title":"LoadBalancerRouting","text":"<p>LoadBalancerRouting is the Schema for the loadbalancerroutings API</p> Field Description <code>apiVersion</code> string <code> networking.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>LoadBalancerRouting</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>networkRef</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.LocalUIDReference  <p>NetworkRef is the network the load balancer is assigned to.</p> <code>destinations</code>  []LoadBalancerDestination  <p>Destinations are the destinations for an LoadBalancer.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NATGateway","title":"NATGateway","text":"<p>NATGateway is the Schema for the NATGateway API</p> Field Description <code>apiVersion</code> string <code> networking.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>NATGateway</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NATGatewaySpec  <code>type</code>  NATGatewayType  <p>Type is the type of NATGateway.</p> <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the ip family the NAT gateway should have.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this NATGateway should belong to.</p> <code>portsPerNetworkInterface</code>  int32  <p>PortsPerNetworkInterface defines the number of concurrent connections per target network interface. Has to be a power of 2. If empty, 2048 (DefaultPortsPerNetworkInterface) is the default.</p> <code>status</code>  NATGatewayStatus"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.Network","title":"Network","text":"<p>Network is the Schema for the network API</p> Field Description <code>apiVersion</code> string <code> networking.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>Network</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NetworkSpec  <code>providerID</code>  string  <p>ProviderID is the provider-internal ID of the network.</p> <code>peerings</code>  []NetworkPeering  (Optional) <p>Peerings are the network peerings with this network.</p> <code>incomingPeerings</code>  []NetworkPeeringClaimRef  (Optional) <p>PeeringClaimRefs are the peering claim references of other networks.</p> <code>status</code>  NetworkStatus"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkInterface","title":"NetworkInterface","text":"<p>NetworkInterface is the Schema for the networkinterfaces API</p> Field Description <code>apiVersion</code> string <code> networking.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>NetworkInterface</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NetworkInterfaceSpec  <code>providerID</code>  string  <p>ProviderID is the provider-internal ID of the network interface.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this NetworkInterface is connected to</p> <code>machineRef</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.LocalUIDReference  <p>MachineRef is the Machine this NetworkInterface is used by</p> <code>ipFamilies</code>  []Kubernetes core/v1.IPFamily  <p>IPFamilies defines which IPFamilies this NetworkInterface is supporting</p> <code>ips</code>  []IPSource  <p>IPs is the list of provided IPs or ephemeral IPs which should be assigned to this NetworkInterface.</p> <code>prefixes</code>  []PrefixSource  <p>Prefixes is the list of provided prefixes or ephemeral prefixes which should be assigned to this NetworkInterface.</p> <code>virtualIP</code>  VirtualIPSource  <p>VirtualIP specifies the virtual ip that should be assigned to this NetworkInterface.</p> <code>attributes</code>  map[string]string  <p>Attributes are provider-specific attributes for the network interface.</p> <code>status</code>  NetworkInterfaceStatus"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPolicy","title":"NetworkPolicy","text":"<p>NetworkPolicy is the Schema for the networkpolicies API</p> Field Description <code>apiVersion</code> string <code> networking.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>NetworkPolicy</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NetworkPolicySpec  <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the network to regulate using this policy.</p> <code>networkInterfaceSelector</code>  Kubernetes meta/v1.LabelSelector  <p>NetworkInterfaceSelector selects the network interfaces that are subject to this policy.</p> <code>ingress</code>  []NetworkPolicyIngressRule  <p>Ingress specifies rules for ingress traffic.</p> <code>egress</code>  []NetworkPolicyEgressRule  <p>Egress specifies rules for egress traffic.</p> <code>policyTypes</code>  []PolicyType  <p>PolicyTypes specifies the types of policies this network policy contains.</p> <code>status</code>  NetworkPolicyStatus"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.VirtualIP","title":"VirtualIP","text":"<p>VirtualIP is the Schema for the virtualips API</p> Field Description <code>apiVersion</code> string <code> networking.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>VirtualIP</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  VirtualIPSpec  <code>type</code>  VirtualIPType  <p>Type is the type of VirtualIP.</p> <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the ip family of the VirtualIP.</p> <code>targetRef</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.LocalUIDReference  <p>TargetRef references the target for this VirtualIP (currently only NetworkInterface).</p> <code>status</code>  VirtualIPStatus"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.EphemeralPrefixSource","title":"EphemeralPrefixSource","text":"<p> (Appears on:IPSource, PrefixSource) </p> <p>EphemeralPrefixSource contains the definition to create an ephemeral (i.e. coupled to the lifetime of the surrounding object) Prefix.</p> Field Description <code>prefixTemplate</code>  github.com/onmetal/onmetal-api/api/ipam/v1alpha1.PrefixTemplateSpec  <p>PrefixTemplate is the template for the Prefix.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.EphemeralVirtualIPSource","title":"EphemeralVirtualIPSource","text":"<p> (Appears on:VirtualIPSource) </p> <p>EphemeralVirtualIPSource contains the definition to create an ephemeral (i.e. coupled to the lifetime of the surrounding object) VirtualIP.</p> Field Description <code>virtualIPTemplate</code>  VirtualIPTemplateSpec  <p>VirtualIPTemplate is the template for the VirtualIP.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.IPBlock","title":"IPBlock","text":"<p> (Appears on:NetworkPolicyPeer) </p> <p>IPBlock specifies an ip block with optional exceptions.</p> Field Description <code>cidr</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IPPrefix  <p>CIDR is a string representing the ip block.</p> <code>except</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.IPPrefix  <p>Except is a slice of CIDRs that should not be included within the specified CIDR. Values will be rejected if they are outside CIDR.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.IPSource","title":"IPSource","text":"<p> (Appears on:LoadBalancerSpec, NetworkInterfaceSpec) </p> <p>IPSource is the definition of how to obtain an IP.</p> Field Description <code>value</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IP  <p>Value specifies an IP by using an IP literal.</p> <code>ephemeral</code>  EphemeralPrefixSource  <p>Ephemeral specifies an IP by creating an ephemeral Prefix to allocate the IP with.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.LoadBalancerDestination","title":"LoadBalancerDestination","text":"<p> (Appears on:LoadBalancerRouting) </p> <p>LoadBalancerDestination is the destination of the load balancer.</p> Field Description <code>ip</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IP  <p>IP is the target IP.</p> <code>targetRef</code>  LoadBalancerTargetRef  <p>TargetRef is the target providing the destination.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.LoadBalancerPort","title":"LoadBalancerPort","text":"<p> (Appears on:LoadBalancerSpec) </p> Field Description <code>protocol</code>  Kubernetes core/v1.Protocol  <p>Protocol is the protocol the load balancer should allow. If not specified, defaults to TCP.</p> <code>port</code>  int32  <p>Port is the port to allow.</p> <code>endPort</code>  int32  <p>EndPort marks the end of the port range to allow. If unspecified, only a single port, Port, will be allowed.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.LoadBalancerSpec","title":"LoadBalancerSpec","text":"<p> (Appears on:LoadBalancer) </p> <p>LoadBalancerSpec defines the desired state of LoadBalancer</p> Field Description <code>type</code>  LoadBalancerType  <p>Type is the type of LoadBalancer.</p> <code>ipFamilies</code>  []Kubernetes core/v1.IPFamily  <p>IPFamilies are the ip families the load balancer should have.</p> <code>ips</code>  []IPSource  <p>IPs are the ips to use. Can only be used when Type is LoadBalancerTypeInternal.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this LoadBalancer should belong to.</p> <code>networkInterfaceSelector</code>  Kubernetes meta/v1.LabelSelector  <p>NetworkInterfaceSelector defines the NetworkInterfaces for which this LoadBalancer should be applied</p> <code>ports</code>  []LoadBalancerPort  <p>Ports are the ports the load balancer should allow.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.LoadBalancerStatus","title":"LoadBalancerStatus","text":"<p> (Appears on:LoadBalancer) </p> <p>LoadBalancerStatus defines the observed state of LoadBalancer</p> Field Description <code>ips</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.IP  <p>IPs are the IPs allocated for the load balancer.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.LoadBalancerTargetRef","title":"LoadBalancerTargetRef","text":"<p> (Appears on:LoadBalancerDestination) </p> <p>LoadBalancerTargetRef is a load balancer target.</p> Field Description <code>uid</code>  k8s.io/apimachinery/pkg/types.UID  <p>UID is the UID of the target.</p> <code>name</code>  string  <p>Name is the name of the target.</p> <code>providerID</code>  string  <p>ProviderID is the provider internal id of the target.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.LoadBalancerType","title":"LoadBalancerType (<code>string</code> alias)","text":"<p> (Appears on:LoadBalancerSpec) </p> <p>LoadBalancerType is a type of LoadBalancer.</p> Value Description <p>\"Internal\"</p> <p>LoadBalancerTypeInternal is a LoadBalancer that allocates and routes network-internal, stable IPs.</p> <p>\"Public\"</p> <p>LoadBalancerTypePublic is a LoadBalancer that allocates and routes a stable public IP.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NATGatewaySpec","title":"NATGatewaySpec","text":"<p> (Appears on:NATGateway) </p> <p>NATGatewaySpec defines the desired state of NATGateway</p> Field Description <code>type</code>  NATGatewayType  <p>Type is the type of NATGateway.</p> <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the ip family the NAT gateway should have.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this NATGateway should belong to.</p> <code>portsPerNetworkInterface</code>  int32  <p>PortsPerNetworkInterface defines the number of concurrent connections per target network interface. Has to be a power of 2. If empty, 2048 (DefaultPortsPerNetworkInterface) is the default.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NATGatewayStatus","title":"NATGatewayStatus","text":"<p> (Appears on:NATGateway) </p> <p>NATGatewayStatus defines the observed state of NATGateway</p> Field Description <code>ips</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.IP  <p>IPs are the IPs allocated for the NAT gateway.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NATGatewayType","title":"NATGatewayType (<code>string</code> alias)","text":"<p> (Appears on:NATGatewaySpec) </p> <p>NATGatewayType is a type of NATGateway.</p> Value Description <p>\"Public\"</p> <p>NATGatewayTypePublic is a NATGateway that allocates and routes a stable public IP.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkInterfaceSpec","title":"NetworkInterfaceSpec","text":"<p> (Appears on:NetworkInterface, NetworkInterfaceTemplateSpec) </p> <p>NetworkInterfaceSpec defines the desired state of NetworkInterface</p> Field Description <code>providerID</code>  string  <p>ProviderID is the provider-internal ID of the network interface.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this NetworkInterface is connected to</p> <code>machineRef</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.LocalUIDReference  <p>MachineRef is the Machine this NetworkInterface is used by</p> <code>ipFamilies</code>  []Kubernetes core/v1.IPFamily  <p>IPFamilies defines which IPFamilies this NetworkInterface is supporting</p> <code>ips</code>  []IPSource  <p>IPs is the list of provided IPs or ephemeral IPs which should be assigned to this NetworkInterface.</p> <code>prefixes</code>  []PrefixSource  <p>Prefixes is the list of provided prefixes or ephemeral prefixes which should be assigned to this NetworkInterface.</p> <code>virtualIP</code>  VirtualIPSource  <p>VirtualIP specifies the virtual ip that should be assigned to this NetworkInterface.</p> <code>attributes</code>  map[string]string  <p>Attributes are provider-specific attributes for the network interface.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkInterfaceState","title":"NetworkInterfaceState (<code>string</code> alias)","text":"<p> (Appears on:NetworkInterfaceStatus) </p> <p>NetworkInterfaceState is the onmetal-api state of a NetworkInterface.</p> Value Description <p>\"Available\"</p> <p>NetworkInterfaceStateAvailable is used for any NetworkInterface where all properties are valid.</p> <p>\"Error\"</p> <p>NetworkInterfaceStateError is used for any NetworkInterface where any property has an error.</p> <p>\"Pending\"</p> <p>NetworkInterfaceStatePending is used for any NetworkInterface that is pending.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkInterfaceStatus","title":"NetworkInterfaceStatus","text":"<p> (Appears on:NetworkInterface) </p> <p>NetworkInterfaceStatus defines the observed state of NetworkInterface</p> Field Description <code>state</code>  NetworkInterfaceState  <p>State is the NetworkInterfaceState of the NetworkInterface.</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned from one value to another.</p> <code>ips</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.IP  <p>IPs represent the effective IP addresses of the NetworkInterface.</p> <code>prefixes</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.IPPrefix  <p>Prefixes represent the prefixes routed to the NetworkInterface.</p> <code>virtualIP</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IP  <p>VirtualIP is any virtual ip assigned to the NetworkInterface.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkInterfaceTemplateSpec","title":"NetworkInterfaceTemplateSpec","text":"<p>NetworkInterfaceTemplateSpec is the specification of a NetworkInterface template.</p> Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NetworkInterfaceSpec  <code>providerID</code>  string  <p>ProviderID is the provider-internal ID of the network interface.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this NetworkInterface is connected to</p> <code>machineRef</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.LocalUIDReference  <p>MachineRef is the Machine this NetworkInterface is used by</p> <code>ipFamilies</code>  []Kubernetes core/v1.IPFamily  <p>IPFamilies defines which IPFamilies this NetworkInterface is supporting</p> <code>ips</code>  []IPSource  <p>IPs is the list of provided IPs or ephemeral IPs which should be assigned to this NetworkInterface.</p> <code>prefixes</code>  []PrefixSource  <p>Prefixes is the list of provided prefixes or ephemeral prefixes which should be assigned to this NetworkInterface.</p> <code>virtualIP</code>  VirtualIPSource  <p>VirtualIP specifies the virtual ip that should be assigned to this NetworkInterface.</p> <code>attributes</code>  map[string]string  <p>Attributes are provider-specific attributes for the network interface.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPeering","title":"NetworkPeering","text":"<p> (Appears on:NetworkSpec) </p> <p>NetworkPeering defines a network peering with another network.</p> Field Description <code>name</code>  string  <p>Name is the semantical name of the network peering.</p> <code>networkRef</code>  NetworkPeeringNetworkRef  <p>NetworkRef is the reference to the network to peer with. An empty namespace indicates that the target network resides in the same namespace as the source network.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPeeringClaimRef","title":"NetworkPeeringClaimRef","text":"<p> (Appears on:NetworkSpec) </p> Field Description <code>namespace</code>  string  <p>Namespace is the namespace of the referenced entity. If empty, the same namespace as the referring resource is implied.</p> <code>name</code>  string  <p>Name is the name of the referenced entity.</p> <code>uid</code>  k8s.io/apimachinery/pkg/types.UID  <p>UID is the UID of the referenced entity.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPeeringNetworkRef","title":"NetworkPeeringNetworkRef","text":"<p> (Appears on:NetworkPeering) </p> <p>NetworkPeeringNetworkRef is a reference to a network to peer with.</p> Field Description <code>namespace</code>  string  <p>Namespace is the namespace of the referenced entity. If empty, the same namespace as the referring resource is implied.</p> <code>name</code>  string  <p>Name is the name of the referenced entity.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPeeringStatus","title":"NetworkPeeringStatus","text":"<p> (Appears on:NetworkStatus) </p> <p>NetworkPeeringStatus is the status of a network peering.</p> Field Description <code>name</code>  string  <p>Name is the name of the network peering.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPolicyCondition","title":"NetworkPolicyCondition","text":"<p> (Appears on:NetworkPolicyStatus) </p> <p>NetworkPolicyCondition is one of the conditions of a network policy.</p> Field Description <code>type</code>  NetworkPolicyConditionType  <p>Type is the type of the condition.</p> <code>status</code>  Kubernetes core/v1.ConditionStatus  <p>Status is the status of the condition.</p> <code>reason</code>  string  <p>Reason is a machine-readable indication of why the condition is in a certain state.</p> <code>message</code>  string  <p>Message is a human-readable explanation of why the condition has a certain reason / state.</p> <code>observedGeneration</code>  int64  <p>ObservedGeneration represents the .metadata.generation that the condition was set based upon.</p> <code>lastTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastTransitionTime is the last time the status of a condition has transitioned from one state to another.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPolicyConditionType","title":"NetworkPolicyConditionType (<code>string</code> alias)","text":"<p> (Appears on:NetworkPolicyCondition) </p> <p>NetworkPolicyConditionType is a type a NetworkPolicyCondition can have.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPolicyEgressRule","title":"NetworkPolicyEgressRule","text":"<p> (Appears on:NetworkPolicySpec) </p> <p>NetworkPolicyEgressRule describes a rule to regulate egress traffic with.</p> Field Description <code>ports</code>  []NetworkPolicyPort  <p>Ports specifies the list of destination ports that can be called with this rule. Each item in this list is combined using a logical OR. Empty matches all ports. As soon as a single item is present, only these ports are allowed.</p> <code>to</code>  []NetworkPolicyPeer  <p>To specifies the list of destinations which the selected network interfaces should be able to send traffic to. Fields are combined using a logical OR. Empty matches all destinations. As soon as a single item is present, only these peers are allowed.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPolicyIngressRule","title":"NetworkPolicyIngressRule","text":"<p> (Appears on:NetworkPolicySpec) </p> <p>NetworkPolicyIngressRule describes a rule to regulate ingress traffic with.</p> Field Description <code>ports</code>  []NetworkPolicyPort  <p>Ports specifies the list of ports which should be made accessible for this rule. Each item in this list is combined using a logical OR. Empty matches all ports. As soon as a single item is present, only these ports are allowed.</p> <code>from</code>  []NetworkPolicyPeer  <p>From specifies the list of sources which should be able to send traffic to the selected network interfaces. Fields are combined using a logical OR. Empty matches all sources. As soon as a single item is present, only these peers are allowed.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPolicyPeer","title":"NetworkPolicyPeer","text":"<p> (Appears on:NetworkPolicyEgressRule, NetworkPolicyIngressRule) </p> <p>NetworkPolicyPeer describes a peer to allow traffic to / from.</p> Field Description <code>objectSelector</code>  github.com/onmetal/onmetal-api/api/core/v1alpha1.ObjectSelector  <p>ObjectSelector selects peers with the given kind matching the label selector. Exclusive with other peer specifiers.</p> <code>ipBlock</code>  IPBlock  <p>IPBlock specifies the ip block from or to which network traffic may come.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPolicyPort","title":"NetworkPolicyPort","text":"<p> (Appears on:NetworkPolicyEgressRule, NetworkPolicyIngressRule) </p> <p>NetworkPolicyPort describes a port to allow traffic on</p> Field Description <code>protocol</code>  Kubernetes core/v1.Protocol  <p>Protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field defaults to TCP.</p> <code>port</code>  int32  <p>The port on the given protocol. If this field is not provided, this matches all port names and numbers. If present, only traffic on the specified protocol AND port will be matched.</p> <code>endPort</code>  int32  <p>EndPort indicates that the range of ports from Port to EndPort, inclusive, should be allowed by the policy. This field cannot be defined if the port field is not defined. The endPort must be equal or greater than port.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPolicySpec","title":"NetworkPolicySpec","text":"<p> (Appears on:NetworkPolicy) </p> <p>NetworkPolicySpec defines the desired state of NetworkPolicy.</p> Field Description <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the network to regulate using this policy.</p> <code>networkInterfaceSelector</code>  Kubernetes meta/v1.LabelSelector  <p>NetworkInterfaceSelector selects the network interfaces that are subject to this policy.</p> <code>ingress</code>  []NetworkPolicyIngressRule  <p>Ingress specifies rules for ingress traffic.</p> <code>egress</code>  []NetworkPolicyEgressRule  <p>Egress specifies rules for egress traffic.</p> <code>policyTypes</code>  []PolicyType  <p>PolicyTypes specifies the types of policies this network policy contains.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkPolicyStatus","title":"NetworkPolicyStatus","text":"<p> (Appears on:NetworkPolicy) </p> <p>NetworkPolicyStatus defines the observed state of NetworkPolicy.</p> Field Description <code>conditions</code>  []NetworkPolicyCondition  <p>Conditions are various conditions of the NetworkPolicy.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkSpec","title":"NetworkSpec","text":"<p> (Appears on:Network) </p> <p>NetworkSpec defines the desired state of Network</p> Field Description <code>providerID</code>  string  <p>ProviderID is the provider-internal ID of the network.</p> <code>peerings</code>  []NetworkPeering  (Optional) <p>Peerings are the network peerings with this network.</p> <code>incomingPeerings</code>  []NetworkPeeringClaimRef  (Optional) <p>PeeringClaimRefs are the peering claim references of other networks.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkState","title":"NetworkState (<code>string</code> alias)","text":"<p> (Appears on:NetworkStatus) </p> <p>NetworkState is the state of a network.</p> Value Description <p>\"Available\"</p> <p>NetworkStateAvailable means the network is ready to use.</p> <p>\"Error\"</p> <p>NetworkStateError means the network is in an error state.</p> <p>\"Pending\"</p> <p>NetworkStatePending means the network is being provisioned.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.NetworkStatus","title":"NetworkStatus","text":"<p> (Appears on:Network) </p> <p>NetworkStatus defines the observed state of Network</p> Field Description <code>state</code>  NetworkState  <p>State is the state of the machine.</p> <code>peerings</code>  []NetworkPeeringStatus  (Optional) <p>Peerings contains the states of the network peerings for the network.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.PolicyType","title":"PolicyType (<code>string</code> alias)","text":"<p> (Appears on:NetworkPolicySpec) </p> <p>PolicyType is a type of policy.</p> Value Description <p>\"Egress\"</p> <p>PolicyTypeEgress is a policy that describes egress traffic.</p> <p>\"Ingress\"</p> <p>PolicyTypeIngress is a policy that describes ingress traffic.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.PrefixSource","title":"PrefixSource","text":"<p> (Appears on:NetworkInterfaceSpec) </p> Field Description <code>value</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IPPrefix  <p>Value specifies a static prefix to use.</p> <code>ephemeral</code>  EphemeralPrefixSource  <p>Ephemeral specifies a prefix by creating an ephemeral ipam.Prefix to allocate the prefix with.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.VirtualIPSource","title":"VirtualIPSource","text":"<p> (Appears on:NetworkInterfaceSpec) </p> <p>VirtualIPSource is the definition of how to obtain a VirtualIP.</p> Field Description <code>virtualIPRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VirtualIPRef references a VirtualIP to use.</p> <code>ephemeral</code>  EphemeralVirtualIPSource  <p>Ephemeral instructs to create an ephemeral (i.e. coupled to the lifetime of the surrounding object) VirtualIP.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.VirtualIPSpec","title":"VirtualIPSpec","text":"<p> (Appears on:VirtualIP, VirtualIPTemplateSpec) </p> <p>VirtualIPSpec defines the desired state of VirtualIP</p> Field Description <code>type</code>  VirtualIPType  <p>Type is the type of VirtualIP.</p> <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the ip family of the VirtualIP.</p> <code>targetRef</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.LocalUIDReference  <p>TargetRef references the target for this VirtualIP (currently only NetworkInterface).</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.VirtualIPStatus","title":"VirtualIPStatus","text":"<p> (Appears on:VirtualIP) </p> <p>VirtualIPStatus defines the observed state of VirtualIP</p> Field Description <code>ip</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.IP  <p>IP is the allocated IP, if any.</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.VirtualIPTemplateSpec","title":"VirtualIPTemplateSpec","text":"<p> (Appears on:EphemeralVirtualIPSource) </p> <p>VirtualIPTemplateSpec is the specification of a VirtualIP template.</p> Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  VirtualIPSpec  <code>type</code>  VirtualIPType  <p>Type is the type of VirtualIP.</p> <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the ip family of the VirtualIP.</p> <code>targetRef</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.LocalUIDReference  <p>TargetRef references the target for this VirtualIP (currently only NetworkInterface).</p>"},{"location":"api-reference/networking/#networking.api.onmetal.de/v1alpha1.VirtualIPType","title":"VirtualIPType (<code>string</code> alias)","text":"<p> (Appears on:VirtualIPSpec) </p> <p>VirtualIPType is a type of VirtualIP.</p> Value Description <p>\"Public\"</p> <p>VirtualIPTypePublic is a VirtualIP that allocates and routes a stable public IP.</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"api-reference/overview/","title":"API Reference Documentation","text":"<p>This is the home of the API reference documentation grouped by the various API groups. The content in each subgroup is automatically generated from the Go types in the <code>apis</code> folder. For more information on how the documentation is built and how it can be updated please refer to the Updating API Reference Documentation in the documentation development guide.</p> <ul> <li>Core</li> <li>IPAM</li> <li>Compute</li> <li>Networking</li> <li>Storage</li> <li>Common</li> </ul>"},{"location":"api-reference/storage/","title":"Storage","text":"<p>Packages:</p> <ul> <li> storage.api.onmetal.de/v1alpha1 </li> </ul>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1","title":"storage.api.onmetal.de/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p> <ul><li> Bucket </li><li> BucketClass </li><li> BucketPool </li><li> Volume </li><li> VolumeClass </li><li> VolumePool </li></ul>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.Bucket","title":"Bucket","text":"<p>Bucket is the Schema for the buckets API</p> Field Description <code>apiVersion</code> string <code> storage.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>Bucket</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  BucketSpec  <code>bucketClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>BucketClassRef is the BucketClass of a bucket If empty, an external controller has to provision the bucket.</p> <code>bucketPoolSelector</code>  map[string]string  <p>BucketPoolSelector selects a suitable BucketPoolRef by the given labels.</p> <code>bucketPoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>BucketPoolRef indicates which BucketPool to use for a bucket. If unset, the scheduler will figure out a suitable BucketPoolRef.</p> <code>tolerations</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Bucket has. Only any BucketPool whose taints covered by Tolerations will be considered to host the Bucket.</p> <code>status</code>  BucketStatus"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.BucketClass","title":"BucketClass","text":"<p>BucketClass is the Schema for the bucketclasses API</p> Field Description <code>apiVersion</code> string <code> storage.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>BucketClass</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>capabilities</code>  github.com/onmetal/onmetal-api/api/core/v1alpha1.ResourceList  <p>Capabilities describes the capabilities of a BucketClass.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.BucketPool","title":"BucketPool","text":"<p>BucketPool is the Schema for the bucketpools API</p> Field Description <code>apiVersion</code> string <code> storage.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>BucketPool</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  BucketPoolSpec  <code>providerID</code>  string  <p>ProviderID identifies the BucketPool on provider side.</p> <code>taints</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Taint  <p>Taints of the BucketPool. Only Buckets who tolerate all the taints will land in the BucketPool.</p> <code>status</code>  BucketPoolStatus"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.Volume","title":"Volume","text":"<p>Volume is the Schema for the volumes API</p> Field Description <code>apiVersion</code> string <code> storage.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>Volume</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  VolumeSpec  <code>volumeClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumeClassRef is the VolumeClass of a volume If empty, an external controller has to provision the volume.</p> <code>volumePoolSelector</code>  map[string]string  <p>VolumePoolSelector selects a suitable VolumePoolRef by the given labels.</p> <code>volumePoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumePoolRef indicates which VolumePool to use for a volume. If unset, the scheduler will figure out a suitable VolumePoolRef.</p> <code>claimRef</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.LocalUIDReference  <p>ClaimRef is the reference to the claiming entity of the Volume.</p> <code>resources</code>  github.com/onmetal/onmetal-api/api/core/v1alpha1.ResourceList  <p>Resources is a description of the volume\u2019s resources and capacity.</p> <code>image</code>  string  <p>Image is an optional image to bootstrap the volume with.</p> <code>imagePullSecretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>ImagePullSecretRef is an optional secret for pulling the image of a volume.</p> <code>unclaimable</code>  bool  <p>Unclaimable marks the volume as unclaimable.</p> <code>tolerations</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Volume has. Only any VolumePool whose taints covered by Tolerations will be considered to host the Volume.</p> <code>encryption</code>  VolumeEncryption  <p>Encryption is an optional field which provides attributes to encrypt Volume.</p> <code>status</code>  VolumeStatus"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumeClass","title":"VolumeClass","text":"<p>VolumeClass is the Schema for the volumeclasses API</p> Field Description <code>apiVersion</code> string <code> storage.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>VolumeClass</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>capabilities</code>  github.com/onmetal/onmetal-api/api/core/v1alpha1.ResourceList  <p>Capabilities describes the capabilities of a VolumeClass.</p> <code>resizePolicy</code>  ResizePolicy  <p>ResizePolicy describes the supported expansion policy of a VolumeClass. If not set default to Static expansion policy.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumePool","title":"VolumePool","text":"<p>VolumePool is the Schema for the volumepools API</p> Field Description <code>apiVersion</code> string <code> storage.api.onmetal.de/v1alpha1 </code> <code>kind</code> string  <code>VolumePool</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  VolumePoolSpec  <code>providerID</code>  string  <p>ProviderID identifies the VolumePool on provider side.</p> <code>taints</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Taint  <p>Taints of the VolumePool. Only Volumes who tolerate all the taints will land in the VolumePool.</p> <code>status</code>  VolumePoolStatus"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.BucketAccess","title":"BucketAccess","text":"<p> (Appears on:BucketStatus) </p> <p>BucketAccess represents information on how to access a bucket.</p> Field Description <code>secretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>SecretRef references the Secret containing the access credentials to consume a Bucket.</p> <code>endpoint</code>  string  <p>Endpoint defines address of the Bucket REST-API.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.BucketCondition","title":"BucketCondition","text":"<p> (Appears on:BucketStatus) </p> <p>BucketCondition is one of the conditions of a bucket.</p> Field Description <code>type</code>  BucketConditionType  <p>Type is the type of the condition.</p> <code>status</code>  Kubernetes core/v1.ConditionStatus  <p>Status is the status of the condition.</p> <code>reason</code>  string  <p>Reason is a machine-readable indication of why the condition is in a certain state.</p> <code>message</code>  string  <p>Message is a human-readable explanation of why the condition has a certain reason / state.</p> <code>observedGeneration</code>  int64  <p>ObservedGeneration represents the .metadata.generation that the condition was set based upon.</p> <code>lastTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastTransitionTime is the last time the status of a condition has transitioned from one state to another.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.BucketConditionType","title":"BucketConditionType (<code>string</code> alias)","text":"<p> (Appears on:BucketCondition) </p> <p>BucketConditionType is a type a BucketCondition can have.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.BucketPoolSpec","title":"BucketPoolSpec","text":"<p> (Appears on:BucketPool) </p> <p>BucketPoolSpec defines the desired state of BucketPool</p> Field Description <code>providerID</code>  string  <p>ProviderID identifies the BucketPool on provider side.</p> <code>taints</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Taint  <p>Taints of the BucketPool. Only Buckets who tolerate all the taints will land in the BucketPool.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.BucketPoolState","title":"BucketPoolState (<code>string</code> alias)","text":"<p> (Appears on:BucketPoolStatus) </p> Value Description <p>\"Available\"</p> <p>\"Pending\"</p> <p>\"Unavailable\"</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.BucketPoolStatus","title":"BucketPoolStatus","text":"<p> (Appears on:BucketPool) </p> <p>BucketPoolStatus defines the observed state of BucketPool</p> Field Description <code>state</code>  BucketPoolState  <p>State represents the infrastructure state of a BucketPool.</p> <code>availableBucketClasses</code>  []Kubernetes core/v1.LocalObjectReference  <p>AvailableBucketClasses list the references of any supported BucketClass of this pool</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.BucketSpec","title":"BucketSpec","text":"<p> (Appears on:Bucket, BucketTemplateSpec) </p> <p>BucketSpec defines the desired state of Bucket</p> Field Description <code>bucketClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>BucketClassRef is the BucketClass of a bucket If empty, an external controller has to provision the bucket.</p> <code>bucketPoolSelector</code>  map[string]string  <p>BucketPoolSelector selects a suitable BucketPoolRef by the given labels.</p> <code>bucketPoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>BucketPoolRef indicates which BucketPool to use for a bucket. If unset, the scheduler will figure out a suitable BucketPoolRef.</p> <code>tolerations</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Bucket has. Only any BucketPool whose taints covered by Tolerations will be considered to host the Bucket.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.BucketState","title":"BucketState (<code>string</code> alias)","text":"<p> (Appears on:BucketStatus) </p> <p>BucketState represents the infrastructure state of a Bucket.</p> Value Description <p>\"Available\"</p> <p>BucketStateAvailable reports whether a Bucket is available to be used.</p> <p>\"Error\"</p> <p>BucketStateError reports that a Bucket is in an error state.</p> <p>\"Pending\"</p> <p>BucketStatePending reports whether a Bucket is about to be ready.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.BucketStatus","title":"BucketStatus","text":"<p> (Appears on:Bucket) </p> <p>BucketStatus defines the observed state of Bucket</p> Field Description <code>state</code>  BucketState  <p>State represents the infrastructure state of a Bucket.</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned between values.</p> <code>access</code>  BucketAccess  <p>Access specifies how to access a Bucket. This is set by the bucket provider when the bucket is provisioned.</p> <code>conditions</code>  []BucketCondition  <p>Conditions are the conditions of a bucket.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.BucketTemplateSpec","title":"BucketTemplateSpec","text":"<p>BucketTemplateSpec is the specification of a Bucket template.</p> Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  BucketSpec  <code>bucketClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>BucketClassRef is the BucketClass of a bucket If empty, an external controller has to provision the bucket.</p> <code>bucketPoolSelector</code>  map[string]string  <p>BucketPoolSelector selects a suitable BucketPoolRef by the given labels.</p> <code>bucketPoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>BucketPoolRef indicates which BucketPool to use for a bucket. If unset, the scheduler will figure out a suitable BucketPoolRef.</p> <code>tolerations</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Bucket has. Only any BucketPool whose taints covered by Tolerations will be considered to host the Bucket.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.ResizePolicy","title":"ResizePolicy (<code>string</code> alias)","text":"<p> (Appears on:VolumeClass) </p> <p>ResizePolicy is a type of policy.</p> Value Description <p>\"ExpandOnly\"</p> <p>ResizePolicyExpandOnly is a policy that only allows the expansion of a Volume.</p> <p>\"Static\"</p> <p>ResizePolicyStatic is a policy that does not allow the expansion of a Volume.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumeAccess","title":"VolumeAccess","text":"<p> (Appears on:VolumeStatus) </p> <p>VolumeAccess represents information on how to access a volume.</p> Field Description <code>secretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>SecretRef references the Secret containing the access credentials to consume a Volume.</p> <code>driver</code>  string  <p>Driver is the name of the drive to use for this volume. Required.</p> <code>handle</code>  string  <p>Handle is the unique handle of the volume.</p> <code>volumeAttributes</code>  map[string]string  <p>VolumeAttributes are attributes of the volume to use.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumeCondition","title":"VolumeCondition","text":"<p> (Appears on:VolumeStatus) </p> <p>VolumeCondition is one of the conditions of a volume.</p> Field Description <code>type</code>  VolumeConditionType  <p>Type is the type of the condition.</p> <code>status</code>  Kubernetes core/v1.ConditionStatus  <p>Status is the status of the condition.</p> <code>reason</code>  string  <p>Reason is a machine-readable indication of why the condition is in a certain state.</p> <code>message</code>  string  <p>Message is a human-readable explanation of why the condition has a certain reason / state.</p> <code>observedGeneration</code>  int64  <p>ObservedGeneration represents the .metadata.generation that the condition was set based upon.</p> <code>lastTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastTransitionTime is the last time the status of a condition has transitioned from one state to another.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumeConditionType","title":"VolumeConditionType (<code>string</code> alias)","text":"<p> (Appears on:VolumeCondition) </p> <p>VolumeConditionType is a type a VolumeCondition can have.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumeEncryption","title":"VolumeEncryption","text":"<p> (Appears on:VolumeSpec) </p> <p>VolumeEncryption represents information to encrypt a volume.</p> Field Description <code>secretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>SecretRef references the Secret containing the encryption key to encrypt a Volume. This secret is created by user with encryptionKey as Key and base64 encoded 256-bit encryption key as Value.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumePoolCondition","title":"VolumePoolCondition","text":"<p> (Appears on:VolumePoolStatus) </p> <p>VolumePoolCondition is one of the conditions of a volume.</p> Field Description <code>type</code>  VolumePoolConditionType  <p>Type is the type of the condition.</p> <code>status</code>  Kubernetes core/v1.ConditionStatus  <p>Status is the status of the condition.</p> <code>reason</code>  string  <p>Reason is a machine-readable indication of why the condition is in a certain state.</p> <code>message</code>  string  <p>Message is a human-readable explanation of why the condition has a certain reason / state.</p> <code>observedGeneration</code>  int64  <p>ObservedGeneration represents the .metadata.generation that the condition was set based upon.</p> <code>lastTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastTransitionTime is the last time the status of a condition has transitioned from one state to another.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumePoolConditionType","title":"VolumePoolConditionType (<code>string</code> alias)","text":"<p> (Appears on:VolumePoolCondition) </p> <p>VolumePoolConditionType is a type a VolumePoolCondition can have.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumePoolSpec","title":"VolumePoolSpec","text":"<p> (Appears on:VolumePool) </p> <p>VolumePoolSpec defines the desired state of VolumePool</p> Field Description <code>providerID</code>  string  <p>ProviderID identifies the VolumePool on provider side.</p> <code>taints</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Taint  <p>Taints of the VolumePool. Only Volumes who tolerate all the taints will land in the VolumePool.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumePoolState","title":"VolumePoolState (<code>string</code> alias)","text":"<p> (Appears on:VolumePoolStatus) </p> Value Description <p>\"Available\"</p> <p>\"Pending\"</p> <p>\"Unavailable\"</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumePoolStatus","title":"VolumePoolStatus","text":"<p> (Appears on:VolumePool) </p> <p>VolumePoolStatus defines the observed state of VolumePool</p> Field Description <code>state</code>  VolumePoolState  <code>conditions</code>  []VolumePoolCondition  <code>availableVolumeClasses</code>  []Kubernetes core/v1.LocalObjectReference  <p>AvailableVolumeClasses list the references of any supported VolumeClass of this pool</p> <code>capacity</code>  github.com/onmetal/onmetal-api/api/core/v1alpha1.ResourceList  <p>Capacity represents the total resources of a machine pool.</p> <code>allocatable</code>  github.com/onmetal/onmetal-api/api/core/v1alpha1.ResourceList  <p>Allocatable represents the resources of a machine pool that are available for scheduling.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumeSpec","title":"VolumeSpec","text":"<p> (Appears on:Volume, VolumeTemplateSpec) </p> <p>VolumeSpec defines the desired state of Volume</p> Field Description <code>volumeClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumeClassRef is the VolumeClass of a volume If empty, an external controller has to provision the volume.</p> <code>volumePoolSelector</code>  map[string]string  <p>VolumePoolSelector selects a suitable VolumePoolRef by the given labels.</p> <code>volumePoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumePoolRef indicates which VolumePool to use for a volume. If unset, the scheduler will figure out a suitable VolumePoolRef.</p> <code>claimRef</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.LocalUIDReference  <p>ClaimRef is the reference to the claiming entity of the Volume.</p> <code>resources</code>  github.com/onmetal/onmetal-api/api/core/v1alpha1.ResourceList  <p>Resources is a description of the volume\u2019s resources and capacity.</p> <code>image</code>  string  <p>Image is an optional image to bootstrap the volume with.</p> <code>imagePullSecretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>ImagePullSecretRef is an optional secret for pulling the image of a volume.</p> <code>unclaimable</code>  bool  <p>Unclaimable marks the volume as unclaimable.</p> <code>tolerations</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Volume has. Only any VolumePool whose taints covered by Tolerations will be considered to host the Volume.</p> <code>encryption</code>  VolumeEncryption  <p>Encryption is an optional field which provides attributes to encrypt Volume.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumeState","title":"VolumeState (<code>string</code> alias)","text":"<p> (Appears on:VolumeStatus) </p> <p>VolumeState represents the infrastructure state of a Volume.</p> Value Description <p>\"Available\"</p> <p>VolumeStateAvailable reports whether a Volume is available to be used.</p> <p>\"Error\"</p> <p>VolumeStateError reports that a Volume is in an error state.</p> <p>\"Pending\"</p> <p>VolumeStatePending reports whether a Volume is about to be ready.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumeStatus","title":"VolumeStatus","text":"<p> (Appears on:Volume) </p> <p>VolumeStatus defines the observed state of Volume</p> Field Description <code>state</code>  VolumeState  <p>State represents the infrastructure state of a Volume.</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned between values.</p> <code>access</code>  VolumeAccess  <p>Access specifies how to access a Volume. This is set by the volume provider when the volume is provisioned.</p> <code>conditions</code>  []VolumeCondition  <p>Conditions are the conditions of a volume.</p>"},{"location":"api-reference/storage/#storage.api.onmetal.de/v1alpha1.VolumeTemplateSpec","title":"VolumeTemplateSpec","text":"<p>VolumeTemplateSpec is the specification of a Volume template.</p> Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  VolumeSpec  <code>volumeClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumeClassRef is the VolumeClass of a volume If empty, an external controller has to provision the volume.</p> <code>volumePoolSelector</code>  map[string]string  <p>VolumePoolSelector selects a suitable VolumePoolRef by the given labels.</p> <code>volumePoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumePoolRef indicates which VolumePool to use for a volume. If unset, the scheduler will figure out a suitable VolumePoolRef.</p> <code>claimRef</code>  github.com/onmetal/onmetal-api/api/common/v1alpha1.LocalUIDReference  <p>ClaimRef is the reference to the claiming entity of the Volume.</p> <code>resources</code>  github.com/onmetal/onmetal-api/api/core/v1alpha1.ResourceList  <p>Resources is a description of the volume\u2019s resources and capacity.</p> <code>image</code>  string  <p>Image is an optional image to bootstrap the volume with.</p> <code>imagePullSecretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>ImagePullSecretRef is an optional secret for pulling the image of a volume.</p> <code>unclaimable</code>  bool  <p>Unclaimable marks the volume as unclaimable.</p> <code>tolerations</code>  []github.com/onmetal/onmetal-api/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Volume has. Only any VolumePool whose taints covered by Tolerations will be considered to host the Volume.</p> <code>encryption</code>  VolumeEncryption  <p>Encryption is an optional field which provides attributes to encrypt Volume.</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"concepts/machine-exec-flow/","title":"Machine Exec","text":"<p>The <code>exec</code> feature allows accessing the serial console of a <code>compute.Machine</code> via the <code>onmetal-apiserver</code>. The following parties are involved in implementing <code>exec</code>:</p> <ul> <li><code>onmetal-apiserver</code></li> <li><code>machinepollet</code></li> <li><code>ori-machine</code> implementor</li> </ul> <p>The connection flow between those components looks like the following:</p> <pre><code>sequenceDiagram\n    participant User as user\n    participant OA as onmetal-apiserver\n    participant MP as machinepoollet\n    participant OM as ori-machine implementor\n\n    User-&gt;&gt;OA: exec request with machine name\n    Note over OA: Get machine by name\n    Note over OA: Get machine pool\n    Note over OA: Find suitable address &amp; port\n    Note over OA: Create URL for exec request\n    OA-&gt;&gt;MP: HTTP request to exec URL\n    Note over MP: Check authentication &amp; authorization\n    MP-&gt;&gt;OM: Call Exec method\n    Note over OM: Provide functioning Exec implementation\n    Note over OM: ori-machine implementor generates unique token\n    Note over OM: Token-associated URL is called\n    Note over OM: Calls exec on its target\n    Note over OM: Proxies response from the onmetal-apiserver to the requester\n    OM--&gt;&gt;MP: Returns URL for exec session\n    MP--&gt;&gt;OA: Proxy response\n    OA--&gt;&gt;User: Proxy response</code></pre>"},{"location":"concepts/machine-exec-flow/#onmetal-apiserver","title":"<code>onmetal-apiserver</code>","text":"<p>The <code>onmetal-apiserver</code> implements <code>exec</code> as a custom subresource on the <code>Machine</code> resource. In the <code>onmetal-api</code> REST registry, it is registered as <code>machines/exec</code>.</p> <p>The subresource itself is implemented by implementing the <code>k8s.io/apiserver/pkg/registry/rest.Connecter</code> interface, which allows custom logic for handling <code>CONNECT</code> and their follow-up <code>GET</code> / <code>POST</code> requests.</p> <p>For <code>exec</code>, the <code>onmetal-apiserver</code> knows the name of the machine the user wants to access. It first gets the machine by its name (returning an error if it doesn't exist) and then the machine pool it's assigned to (also returning an error if the machine is not assigned to any pool or the machine pool does not exist).</p> <p>On the machine pool, it looks for a suitable address via the reported <code>MachinePool.Status.Addresses</code>, depending on the configurable preferred address types of the <code>onmetal-apiserver</code>. Once found, it uses the address together with the <code>MachinePool.Status.DaemonEndpoints.MachinepoolletEndpoint.Port</code> to create a URL to make the target <code>exec</code> request to. The URL is of the form</p> <pre><code>https://&lt;host&gt;:&lt;port&gt;/apis/compute.api.onmetal.de/namespaces/&lt;namespace&gt;/machines/&lt;machine/exec\n</code></pre> <p>It then makes an http request to that location and proxies the resulting response to the original requester.</p>"},{"location":"concepts/machine-exec-flow/#machinepoollet","title":"<code>machinepoollet</code>","text":"<p>The <code>machinepoollet</code> provides the HTTP server wrapping the <code>ori-machine</code> implementor. This HTTP server also provides the aforementioned route to serve <code>exec</code> for a machine.</p> <p>When the <code>machinepoollet</code> gets a request to that URL it first checks whether the requesting entity is authenticated &amp; authorized to do an <code>exec</code> request for that machine. It does so by using a delegated authenticator / authorizer against the <code>kube-apiserver</code> the <code>onmetal-apiserver</code> is connected to.</p> <p>Once successfully authenticated &amp; authorized, the <code>machinepoollet</code> calls the <code>Exec</code> method of the <code>ori-machine</code> implementor. This <code>Exec</code> method returns a URL where the <code>exec</code> session for the target machine will be hosted at.</p> <p>It then makes an HTTP request to that URL and proxies the resulting response to the <code>onmetal-apiserver</code>.</p>"},{"location":"concepts/machine-exec-flow/#ori-machine-implementor","title":"<code>ori-machine</code> Implementor","text":"<p>The <code>ori-machine</code> implementor has to provide a functioning <code>Exec</code> implementation that returns the URL where the actual <code>exec</code> session of the machine is hosted at.</p> <p>For the <code>machinebroker</code>, this is implemented by having an HTTP server that associates the request together with a unique randomly generated token and returns a URL containing that token.</p> <p>Once the URL containing that token is called, the <code>machinebroker</code> looks up the corresponding request and calls <code>exec</code> on its target (different from the original) <code>onmetal-apiserver</code> with the machine namespace and name from the stored request. It then proxies the response from the <code>onmetal-apiserver</code> to the requester.</p>"},{"location":"concepts/ori/","title":"ORI - Onmetal Runtime Interface","text":""},{"location":"concepts/ori/#introduction","title":"Introduction","text":"<p>The Onmetal Runtime Interface (ORI) is a GRPC-based abstraction layer introduced to ease the implementation of a <code>poollet</code> and <code>pool provider</code>. </p> <p>A <code>poollet</code> does not have any knowledge how the resources are materialized and where the <code>pool provider</code> runs. The responsibility of the <code>poollet</code> is to collect and resolve the needed dependencies to materialize a resource.</p> <p>A <code>pool provider</code> implements the ORI, where the ORI defines the correct creation and management of resources  handled by a <code>pool provider</code>. A <code>pool provider</code> of the ORI should follow the interface defined in the ORI APIs. </p> <pre><code>graph LR\n    P[poollet] --&gt; ORI\n    ORI{ORI} --&gt; B\n    B[pool provider]</code></pre>"},{"location":"concepts/ori/#pool-provider","title":"<code>pool provider</code>","text":"<p>A <code>pool provider</code> represents a specific implementation of resources managed by a Pool. The implementation details of the <code>pool provider</code> depend on the type of resource it handles, such as Compute or Storage resources.</p> <p>Based on the implementation of a <code>pool provider</code> it can serve multiple use-cases:  - to broker resources between different clusters e.g. volume-broker - to materialize resources e.g. block devices created in a Ceph cluster via the cephlet</p>"},{"location":"concepts/ori/#interface-methods","title":"Interface Methods","text":"<p>The ORI defines several interface methods categorized into Compute, Storage, and Bucket.</p> <ul> <li>Compute Methods</li> <li>Storage Methods</li> <li>Bucket Methods</li> </ul> <p>The ORI definition can be extended in the future with new resource groups.</p>"},{"location":"concepts/ori/#diagram","title":"Diagram","text":"<p>Below is a diagram illustrating the relationship between <code>poollets</code>, ORI, and <code>pool providers</code> in the <code>onmetal-api</code> project.</p> <pre><code>graph TB\n    A[Machine] -- scheduled on --&gt; B[MachinePool]\n    C[Volume] -- scheduled on --&gt; D[VolumePool]\n    B -- announced by --&gt; E[machinepoollet]\n    D -- announced by --&gt; F[volumepoollet]\n    E -- GRPC calls --&gt; G[ORI compute provider]\n    F -- GRPC calls --&gt; H[ORI storage provider]\n    G -.sidecar to.- E\n    H -.sidecar to.- F</code></pre> <p>This diagram illustrates:</p> <ul> <li><code>Machine</code> resources are scheduled on a <code>MachinePool</code> which is announced by the <code>machinepoollet</code>.</li> <li>Similarly, <code>Volume</code> resources are scheduled on a <code>VolumePool</code> which is announced by the <code>volumepoollet</code>.</li> <li>The <code>machinepoollet</code> and <code>volumepoollet</code> each have an ORI <code>provider</code> sidecar, which provides a GRPC interface for  making calls to create, update, or delete resources.</li> <li>The ORI <code>provider</code> (Compute) is a sidecar to the <code>machinepoollet</code> and the ORI <code>provider</code> (Storage) is a sidecar to the  <code>volumepoollet</code>. They handle GRPC calls from their respective <code>poollets</code> and interact with the actual resources.</li> </ul>"},{"location":"development/contribution/","title":"Contributors Guide","text":""},{"location":"development/contribution/#contributing","title":"Contributing","text":"<p>The Gardener on Metal project uses Github to manage reviews of pull requests.</p> <ul> <li> <p>If you are looking to make your first contribution, follow Steps to Contribute</p> </li> <li> <p>If you have a trivial fix or improvement, go ahead and create a pull request and address (with @...) a suitable maintainer of this repository  (see CODEOWNERS  of this repository) in the description of the pull request.</p> </li> <li> <p>If you plan to do something more involved, first discuss your ideas by creating an  issue for this repository. This will avoid unnecessary work and surely give you  and us a good deal of inspiration.</p> </li> </ul> <p>Note</p> <p>Please follow these style guidelines to have your contribution considered by the maintainers: Coding style guidelines Go Code Review Comments, Formatting and style section of Peter Bourgon\u2019s Go: Best Practices for Production Environments.</p>"},{"location":"development/contribution/#steps-to-contribute","title":"Steps to Contribute","text":"<p>Do you want to work on an issue?  You are welcome to claim an existing one by commenting on it in GitHub. </p> <p>Note</p> <p>Perform a cursory search to see if the issue has already been taken by someone else.  This will prevent misunderstanding and duplication of  effort from contributors on the same issue.</p> <p>If you have questions about one of the issues please comment on them and one of the  maintainers will clarify it.</p> <p>We kindly ask you to follow the Pull Request Checklist to ensure reviews can happen accordingly.</p>"},{"location":"development/contribution/#contributing-code","title":"Contributing Code","text":"<p>You are welcome to contribute code to the Gardener on Metal project in order to fix a bug or to implement a new feature.</p> <p>The following rules govern code contributions:</p> <ul> <li>Contributions must be licensed under the Apache 2.0 License</li> <li>You need to sign the Developer Certificate of Origin.</li> </ul>"},{"location":"development/contribution/#contributing-documentation","title":"Contributing Documentation","text":"<p>You are welcome to contribute documentation to the Gardener on Metal project.</p> <p>The following rules govern documentation contributions:</p> <ul> <li>Contributions must be licensed under the Creative Commons Attribution 4.0 International License</li> <li>You need to sign the Developer Certificate of Origin.</li> </ul>"},{"location":"development/contribution/#developer-certificate-of-origin","title":"Developer Certificate of Origin","text":"<p>Due to legal reasons, contributors will be asked to accept a Developer Certificate of Origin (DCO) before they submit  the first pull request to the Gardener on Metal project, this happens in an automated fashion during the submission  process. We use the standard DCO text of the Linux Foundation.</p>"},{"location":"development/contribution/#pull-request-checklist","title":"Pull Request Checklist","text":"<ul> <li>Fork and clone the repository to you local machine.</li> </ul> <pre><code>git clone git@github.com:YOUR_GITHUB_USER/onmetal-api.git\ncd onmetal-api\n</code></pre> <ul> <li>Create a branch from the <code>main</code>  using 'git checkout' command. </li> </ul> <p>Note</p> <p>If needed, rebase to the current <code>main</code> branch before submitting  your pull request. If it doesn't merge properly with <code>main</code> you may be asked to rebase your changes.</p> <pre><code>git checkout -b my_feature\n# rebase if necessary\ngit fetch upstream main\ngit rebase upstream/main\n</code></pre> <ul> <li> <p>Commits should be as small as possible, while ensuring that each commit is correct independently  (i.e. each commit should compile and pass tests).</p> </li> <li> <p>Create your patch and test your changes  before you commit them. Automated test by unit / integration tests are preferred.  If tested manually, provide information about the test scope in the PR description. Now you can commit your changes to your feature branch and push it to your fork.</p> </li> </ul> <pre><code>git add .\ngit commit -m \"Something meaningful\"\ngit push origin my_feature\n</code></pre> <p>Note</p> <p>Alternatively you can amend your commit before pushing if you forgot something by using <code>git commit --amend</code></p> <ul> <li> <p>Create Work In Progress [WIP] pull requests only if you need a clarification or an explicit review before you can  continue your work item.</p> </li> <li> <p>If your patch is not getting reviewed, or you need a specific person to review it, you can @-reply a reviewer asking  for a review in the pull request or a comment.</p> </li> <li> <p>Post review:</p> <ul> <li>If a reviewer requires you to change your commit(s), please test the changes again.</li> <li>Amend the affected commit(s) and force push onto your branch.</li> <li>Set respective comments in your GitHub review as resolved.</li> <li>Create a general PR comment to notify the reviewers that your amendments are ready for another round of review.</li> </ul> </li> </ul>"},{"location":"development/contribution/#issues-and-planning","title":"Issues and Planning","text":"<p>We use GitHub issues to track bugs and enhancement requests. Please provide as much context as possible when you open  an issue. The information you provide must be comprehensive enough to understand, reproduce the behavior and find related reports of  that issue for the assignee.  Therefore, contributors may use but aren't restricted to the issue template provided by the Gardener on Metal maintainers.</p> <p>Issues and pull requests are tracked in the backlog for this project.</p>"},{"location":"development/documentation/","title":"Documentation Setup","text":"<p>The documentation of the onmetal-api project is written primarily using Markdown. All documentation related content can be found in the <code>/docs</code> folder. New content also should be added there. MkDocs and MkDocs Material are then used to render the contents of the <code>/docs</code> folder to have a more user-friendly experience when browsing the projects' documentation.</p> <p>Note</p> <p>One exception to the common contribution process builds the <code>docs/api-reference</code> folder. The folder contains auto-generated CRD reference documentation of the project, no manual contributions should be applied as they will be overwritten in the next generation step. To read more: Updating API Reference Documentation  section.</p>"},{"location":"development/documentation/#requirements","title":"Requirements:","text":"<p>Following tools are required to work on that package.</p> <ul> <li>Kubernetes cluster access to deploy and test the result (via minikube, kind or docker desktop locally)</li> <li>make - to execute build goals</li> <li>docker - to run the local mkdocs environment</li> <li>git - to be able to commit any changes to repository</li> <li>kubectl (&gt;= v1.23.4) - to be able to talk to the kubernetes cluster</li> </ul> <p>Note</p> <p>If you don't have Docker installed on your machine please follow one of those guides:</p> <ul> <li>Docker Desktop for Mac</li> <li>Docker Desktop for Windows</li> <li>Docker Engine for Linux</li> </ul>"},{"location":"development/documentation/#local-development-setup","title":"Local Development Setup","text":"<p>This project contains a local Docker based runtime environment for the documentation part. If you have an access to the docker registry and k8s installation that you can use for development purposes, just run following command and access the output in your browser under http://localhost:8000/:</p> <p><pre><code>make start-docs\n</code></pre> The environment will hot-rebuild your documentation, so there is no need to restart it while you make your changes. If you want to add a new chapter (basically a new file/folder to <code>docs</code> directory) you should add it to the <code>nav</code> section in the <code>mkdocs.yml</code> file in the projects root folder. Use helper Makefile directive to clean up old and stopped container instances.</p> <pre><code>make clean-docs\n</code></pre>"},{"location":"development/documentation/#writing-content","title":"Writing Content","text":""},{"location":"development/documentation/#abbreviations","title":"Abbreviations","text":"<p>Abbreviations are defined centrally in the following file <code>/hack/docs/abbreviations.md</code>. In case you introduce any new abbreviation to your content, please make sure to add a corresponding entry there. Please include the statement <code>--8&lt;-- \"hack/docs/abbreviations.md\"</code> at the end of each Markdown file. This will ensure that the abbreviation highlighting will work correctly.</p>"},{"location":"development/documentation/#api-reference-documentation","title":"API Reference Documentation","text":"<p>The API reference documentation contains auto-generated description from the CRD definition of the onmetal-api project. We are using the gen-crd-api-reference-docs project to generate the content. Under the hood we are using <code>go generate</code> instructions defined in each version type <code>doc.go</code>. The needed instructions to generate documentation for the <code>core/v1alpha1</code> types are in the example below:</p> <p><pre><code>//go:generate gen-crd-api-reference-docs -api-dir . -config ../../../hack/api-reference/core-config.json -template-dir ../../../hack/api-reference/template -out-file ../../../docs/api-reference/core.md\n</code></pre> Together with the comments in the corresponding type files <code>go generate</code> will call the <code>gen-crd-api-reference-doc</code> command to generate the output in the <code>/docs/api-reference</code> folder. The project contains a <code>Makefile</code> routine to generate the reference documentation for all types. In case you change any of the types in the <code>apis</code> folder just run:</p> <pre><code>make docs\n</code></pre> <p>Note</p> <p>The generated output should be part of your pull request.</p>"},{"location":"development/setup/","title":"Local Development Setup","text":""},{"location":"development/setup/#requirements","title":"Requirements","text":"<ul> <li><code>go</code> &gt;= 1.20</li> <li><code>git</code>, <code>make</code> and <code>kubectl</code></li> <li>Kustomize</li> <li>Access to a Kubernetes cluster (Minikube, kind or a   real cluster)</li> </ul>"},{"location":"development/setup/#clone-the-repository","title":"Clone the Repository","text":"<p>To bring up and start locally the <code>onmetal-api</code> project for development purposes you first need to clone the repository.</p> <pre><code>git clone git@github.com:onmetal/onmetal-api.git\ncd onmetal-api\n</code></pre>"},{"location":"development/setup/#install-cert-manager","title":"Install cert-manager","text":"<p>If there is no cert-manager present in the cluster it needs to be installed.</p> <pre><code>kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml\n</code></pre>"},{"location":"development/setup/#install-apis-into-the-cluster","title":"Install APIs into the Cluster","text":"<p>Your Kubernetes API server needs to know about the APIs which come with the <code>onmetal-api</code> project. To install the APIs your cluster, run</p> <pre><code>make install\n</code></pre> <p>Note: This requires the <code>APISERVER_IMG</code> (Makefile default set to <code>apiserver</code>) to be pullable from your kubernetes cluster. For local development with <code>kind</code>, a make target that builds and loads the api server image and then applies the manifests is available via</p> <pre><code>make kind-install\n</code></pre> <p>Note: In case that there are multiple environments running, ensure that <code>kind get clusters</code> is pointing to the default kind cluster.</p>"},{"location":"development/setup/#start-the-controller-manager","title":"Start the Controller Manager","text":"<p>The controller manager can be started via the following command</p> <pre><code>make run\n</code></pre>"},{"location":"development/setup/#apply-sample-manifests","title":"Apply Sample Manifests","text":"<p>The <code>config/samples</code> folder contains samples for all APIs supported by this project. You can apply any of the samples by running</p> <pre><code>kubectl apply -f config/samples/SOME_RESOURCE.yaml\n</code></pre>"},{"location":"development/setup/#rebuilding-api-type-and-manifests","title":"Rebuilding API Type and Manifests","text":"<p>Everytime a change has been done to any of the types definitions, the corresponding manifests and generated code pieces have to be rebuilt.</p> <pre><code>make generate\nmake manifests\n</code></pre> <p>Note: Make sure your APIs are up-to-date by running <code>make install</code> / <code>make kind-install</code> after your code / manifests have been regenerated.</p>"},{"location":"development/setup/#setup-formatting-tools","title":"Setup formatting tools","text":"<p>The project uses <code>gofmt</code> and <code>goimports</code> for formatting. <code>gofmt</code> is used with default settings. While <code>goimports</code> should be used with <code>--local github.com/onmetal</code> flag, so that <code>goimports</code> would sort <code>onmetal</code> pkgs separately.</p> <p>You can automate running formatting tools in your IDE.</p> <ul> <li>VSCode -- add following to the <code>settings.json</code>:</li> </ul> <pre><code>    \"go.formatTool\": \"goimports\",\n    \"gopls\": {\n        \"formatting.local\": \"github.com/onmetal\",\n    },\n</code></pre> <ul> <li>Goland -- go to <code>File -&gt; Settings -&gt; Tools -&gt; File Watchers</code> and replace contents of <code>Arguments</code>   with <code>--local github.com/onmetal -w $FilePath$</code></li> </ul>"},{"location":"development/setup/#cleanup","title":"Cleanup","text":"<p>To remove the APIs from your cluster, simply run</p> <pre><code>make uninstall\n</code></pre>"},{"location":"development/testing/","title":"Testing","text":"<p>This project is using Ginkgo as it's primary testing framework in conjunction with Gomega matcher/assertion library.</p>"},{"location":"development/testing/#unit-tests","title":"Unit Tests","text":"<p>Each package should consist of its own <code>suite_test</code> setup and the corresponding test cases for each component.</p> <p>Example of test suite setup is below:</p> <pre><code>package mypackage\n\nimport (\n    . \"github.com/onsi/ginkgo/v2\"\n    . \"github.com/onsi/gomega\"\n    \"testing\"\n)\n\nfunc Test(t *testing.T) {\n    RegisterFailHandler(ginkgo.Fail)\n    ginkgo.RunSpecs(t, \"MyComponent\")\n}\n</code></pre> <p>The testing code should meet the requirements of be common Ginkgo format</p> <pre><code>package mypackage\n\nimport\n...\n\nvar _ = Describe(\"MyComponent\", func() {\n\n    BeforeEach(func() {\n        // Code to run before each Context\n    })\n\n    Context(\"When doing x\", func() {\n        It(\"Should result in y\", func() {\n            By(\"Creating something in x\")\n            Expect(x.DoSomething()).To(Equal(\"expected result\"))\n        })\n    })\n})\n</code></pre> <p>Note</p> <p>here: Ginkgo documentation. Assertion examples can be found here: Gomega documentation.</p>"},{"location":"development/testing/#controller-tests","title":"Controller Tests","text":"<p>Setup a local Kubernetes control plane in order to write controller tests. Use <code>envtest</code> as a part of the controller-runtime project.</p> <p>Example of <code>suite_test.go</code> inside a controller package is below:</p> <pre><code>package my_controller_package\n\nimport\n...\n\n// Those global vars are needed later.\nvar cfg *rest.Config\nvar k8sClient client.Client\nvar testEnv *envtest.Environment\n\nfunc TestAPIs(t *testing.T) {\n    RegisterFailHandler(Fail)\n\n    RunSpecsWithDefaultAndCustomReporters(t,\n        \"Controller Suite\",\n        []Reporter{printer.NewlineReporter{}})\n}\n\nvar _ = BeforeSuite(func() {\n    ...\n    // Here is the actual envtest setup. Make sure that the path\n    // to your generated CRDs is correct, as it will be injected\n    // directly into the API server once the envtest environment comes up.\n    testEnv = &amp;envtest.Environment{\n        CRDDirectoryPaths:     []string{filepath.Join(\"..\", \"..\", \"..\", \"config\", \"crd\", \"bases\")},\n        ErrorIfCRDPathMissing: true,\n    }\n    ...\n    // Define scheme\n    err = api.AddToScheme(scheme.Scheme)\n    ...\n    // Create a corresponding Kubernetes client.\n    k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})\n    ...\n    k8sManager, err := manager.NewManager(cfg, ctrl.Options{\n        Scheme: scheme.Scheme,\n        // On MacOS it might happen, that the firewall warnings will\n        // popup if you open a port on your machine. It typically\n        // happens due to the metrics endpoint of the controller-manager.\n        // To prevent it, disable it in the local setup\n        // and set the Host parameter to localhost.\n        Host:               \"127.0.0.1\",\n        MetricsBindAddress: \"0\",\n    })\n    ...\n    // Register our reconciler with the manager. In case if you want to test\n    // multiple reconcilers at once you have to register them one by\n    // one in the same fashion as is shown below.\n    err = (&amp;MyObjectReconciler{\n        Client: k8sManager.GetClient(),\n        Scheme: k8sManager.GetScheme(),\n        Log:    ctrl.Log.WithName(\"controllers\").WithName(\"MyObject\"),\n    }).SetupWithManager(k8sManager)\n    ...\n\n    // Start the manager\n    go func() {\n        err = k8sManager.Manager.Start(ctrl.SetupSignalHandler())\n        Expect(err).ToNot(HaveOccurred())\n    }()\n\n}, 60)\n\nvar _ = AfterSuite(func() {\n    By(\"tearing down the test environment\")\n    err := testEnv.Stop()\n    Expect(err).NotTo(HaveOccurred())\n})\n</code></pre> <p>The Ginkgo style tests can be now written in the same manner as described in the Unit Test section. The only difference now is, that you have a working controller manager in the background which is reacting on changes in the Kubernetes API which you can access via the <code>k8sClient</code> to create or modify your resources.</p> <p>More information on the envtest setup you can find in the CRD testing section here: Kubebuilder</p>"},{"location":"development/testing/#webhook-tests","title":"Webhook Tests","text":"<p>Webhook tests are located under <code>pkg/webhooks/{Type}</code>. The <code>suite_test</code> for Webhooks is slighly different than the controller suite.</p> <pre><code>// Register admission types\nerr = admissionv1beta1.AddToScheme(scheme)\n...\n// Start webhook server using Manager\nwebhookInstallOptions := &amp;testEnv.WebhookInstallOptions\nmgr, err := manager.NewManager(cfg, ctrl.Options{\nScheme:             scheme,\nHost:               webhookInstallOptions.LocalServingHost,\nPort:               webhookInstallOptions.LocalServingPort,\nCertDir:            webhookInstallOptions.LocalServingCertDir,\nLeaderElection:     false,\nMetricsBindAddress: \"0\",\n})\n...\n// Setup webhook with manager\nerr = (&amp;FooWebhook{}).SetupWebhookWithManager(mgr)\n...\n// Wait for the webhook server to get ready\ndialer := &amp;net.Dialer{Timeout: time.Second}\naddrPort := fmt.Sprintf(\"%s:%d\", webhookInstallOptions.LocalServingHost,\nwebhookInstallOptions.LocalServingPort)\nEventually(func () error {\nconn, err := tls.DialWithDialer(dialer, \"tcp\", addrPort,\n&amp;tls.Config{InsecureSkipVerify: true})\nif err != nil {\nreturn err\n}\nconn.Close()\nreturn nil\n}).Should(Succeed())\n</code></pre> <p>Test cases are written in a similar fashion as tests for controllers.</p> <p>!!! note MutatingWebhooks (<code>Defaulter</code>) can not change <code>Status</code> fields. Keep this in mind if you write your Webhook tests.</p>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":"<p>Test run can be executed via:</p> <pre><code>make test\n</code></pre>"},{"location":"development/testing/#goland-integration","title":"Goland Integration","text":"<p>Running static Ginkgo/Gomega tests in Golang should work out of the box. However, in order to make the controller test run from within your IDE you need to expose the following environment variable inside your 'Test Run Configuration'</p> <pre><code>KUBEBUILDER_ASSETS=/PATH_TO_MY_WORKSPACE/onmetal/onmetal-api/testbin/bin\n</code></pre> <p>This is typically the location of the Kubernetes control plane binaries on your machine.</p>"},{"location":"proposals/","title":"Proposals","text":"<p>This is the home of the <code>onmetal-api</code> enhancement/extension proposals. You can find the list of accepted proposals  in the poposal folder of our Github repository.</p>"},{"location":"proposals/#submitting-a-new-proposal","title":"Submitting a new proposal","text":"<p>Please use our proposal template to write and submit your proposal via a pull request. </p>"},{"location":"proposals/00-template/","title":"OEP-NNNN: Your short, descriptive title","text":""},{"location":"proposals/00-template/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/00-template/#summary","title":"Summary","text":""},{"location":"proposals/00-template/#motivation","title":"Motivation","text":""},{"location":"proposals/00-template/#goals","title":"Goals","text":""},{"location":"proposals/00-template/#non-goals","title":"Non-Goals","text":""},{"location":"proposals/00-template/#proposal","title":"Proposal","text":""},{"location":"proposals/00-template/#alternatives","title":"Alternatives","text":""},{"location":"proposals/01-networking-integration/","title":"01 networking integration","text":"<p>title: Networking Integration</p> <p>oep-number: 1</p> <p>creation-date: 2022-17-03</p> <p>status: implementable</p> <p>authors:</p> <ul> <li>@adracus</li> <li>@afritzler</li> </ul> <p>reviewers:</p> <ul> <li>@adracus</li> <li>@afritzler</li> <li>@MalteJ</li> <li>@guvenc</li> <li>@gehoern</li> </ul>"},{"location":"proposals/01-networking-integration/#oep-1-networking-integration","title":"OEP-1: Networking Integration","text":""},{"location":"proposals/01-networking-integration/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/01-networking-integration/#summary","title":"Summary","text":"<p>Networking is a crucial part in a modern cloud system: It enables systems to communicate within themselves and to the outside world. Orchestrating traffic, auditing it and gaining visibility of what is the desired state is key to a modern network architecture.</p> <p>Key of this OEP is to define the user-facing network API as well as its implications on any other type and the overall structure of <code>onmetal</code>.</p>"},{"location":"proposals/01-networking-integration/#motivation","title":"Motivation","text":"<p>Without networking, any machine / process running inside a datacenter cannot interact / affect the outside world. Networking is a crucial component that has to be implemented for onmetal to have business value. In a full-fledged state, networking also enables security to the outside world and within a datacenter itself.</p> <p>The basic use case we want to implement with onmetal is a machine that can access the internet and can be reached from the internet.</p>"},{"location":"proposals/01-networking-integration/#goals","title":"Goals","text":"<ul> <li>Define APIs for managing isolated networks. It should be possible to do conflict-free peering of networks in the   future.</li> <li>Define APIs for assigning / routing public IPs / prefixes to members of a network / subnet.</li> <li>Adapt the <code>compute.Machine</code> type to integrate with the network API.</li> <li>Have fully integrated IP address management for all resources (IPAM).</li> <li>It should be possible to extend the API in the future to achieve the following (listed by decreasing priority):<ul> <li>Regulate Communication within a subnet (plus security concepts)</li> <li>Subnet-to-subnet communication (plus security concepts)</li> <li>Isolated network-to-network communication (plus security concepts)</li> <li>Cross-region isolated network-to-network communication (plus security concepts)</li> </ul> </li> </ul>"},{"location":"proposals/01-networking-integration/#non-goals","title":"Non-Goals","text":"<ul> <li>Define Load Balancer APIs (L4 sooner in the future, L7 later)</li> <li>Implement any of the future API extensions listed above</li> <li>Allow a user to bring own public IP prefixes</li> <li>Feature-creep beyond a simplistic MVP</li> </ul>"},{"location":"proposals/01-networking-integration/#proposal","title":"Proposal","text":""},{"location":"proposals/01-networking-integration/#preface","title":"Preface","text":"<p>As onmetal is Kubernetes-API, it should integrate nicely within the existing ecosystem. Some API design choices are made in that regard. For further information about Kubernetes, see the Kubernetes reference .</p> <ul> <li>Kubernetes specifies multiple ip types using <code>IPFamily</code>. This means, that instead of e.g. an object having   <pre><code>ipv4: 10.0.0.1\nipv6: ffff::\n</code></pre>   Kubernetes specifies it as   <pre><code>ipFamilies: [IPv4, IPv6]\nips:\n- 10.0.0.1\n- ffff::\n</code></pre>   The proposal should integrate into Kubernetes by using the same notation.</li> <li>Resources that are created, managed, and deleted in scope of another resource are called <code>ephemeral</code>. An example in   Kubernetes is the <code>Pod.spec.volumes.ephemeralVolume</code> that creates a volume just before a   <code>Pod</code> is created and deletes it alongside the <code>Pod</code> after usage.</li> <li><code>1:1</code> binding between two resources is achieved by both resources referencing each other. This can be seen in   Kubernetes'   <code>PersistentVolumeClaim.Spec.volumeName</code> - <code>PersistentVolume.spec.claimRef</code>.</li> <li><code>1:n</code> binding between two resources is achieved by the resource on <code>n</code> side having a reference to the resource on   the <code>1</code> side. This can be seen in <code>n</code> <code>Pod.spec.nodeName</code> referencing a <code>Node</code>.</li> <li><code>m:n</code> binding between two resources is achieved by using <code>selector</code>s and a 'binding' resource that usually gets   created on-the-fly, though this also usually can be modified. An example can be seen in the relation between   <code>Service</code>s and <code>Pod</code>s. A <code>Service</code> selects multiple <code>Pod</code>s via its <code>.spec.selector</code>. The resulting manifested binding   resource is realized via the <code>Endpoints</code> kind that contains the current target list.</li> </ul> <p>The proposal is divided into two parts: The first part purely focuses on IP address management. The second part defines the actual networking types while allowing the user to use the IP address management features of the first part.</p>"},{"location":"proposals/01-networking-integration/#prefix-type","title":"<code>Prefix</code> type","text":"<p>The <code>Prefix</code> simplifies management of IP prefixes (v4 and v6 are both supported).</p> <p>An <code>Prefix</code> may be a root prefix by specifying no parent / parent selector and a prefix it manages. If an <code>Prefix</code> specifies a parent / parent selector, the requested prefix / prefix length is allocated from the parent (that matches, if selector is used). This means, prefixes can both be allocated dynamically by specifying only a desired prefix length or 'statically' by specifying the desired prefix.</p> <p>Example manifests:</p> <pre><code>apiVersion: ipam.api.onmetal.de/v1alpha1\nkind: Prefix\nmetadata:\n  namespace: default\n  name: my-root-prefix\nspec:\n  prefix: 10.0.0.0/8\nstatus:\n  phase: Allocated\n---\napiVersion: ipam.api.onmetal.de/v1alpha1\nkind: Prefix\nmetadata:\n  namespace: default\n  name: my-sub-prefix\nspec:\n  parentRef:\n    name: my-root-prefix\n#  parentSelector: # A metav1.LabelSelector can be used to select the parent.\n#    matchLabels:\n#      foo: bar\n  prefixLength: 16\n  # prefix: 10.0.0.0/16 # Once successfully allocated, the spec is patched.\nstatus:\n  phase: Pending # This will become `Allocated` once the controller approves it.\n</code></pre>"},{"location":"proposals/01-networking-integration/#network-type","title":"<code>Network</code> type","text":"<p>The namespaced <code>Network</code> type defines a <code>Network</code> bracket. Traffic from, to and within the <code>Network</code> can be managed. A <code>Network</code> has to specify the ip families it wants to allow (same is design as in the Kubernetes <code>Service</code> type).</p> <p>IP address space in a <code>Network</code> is not dictated in any way. A <code>Network</code> however has to accept any claimed IP address space within it. For initial design, a <code>Network</code> will only accept non-overlapping space. In a later version, this may be regulated with a field / policy of some kind.</p> <p>Example manifest:</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: Network\nmetadata:\n  namespace: default\n  name: my-network\n</code></pre>"},{"location":"proposals/01-networking-integration/#the-networkinterface-type","title":"The <code>NetworkInterface</code> type","text":"<p>A <code>NetworkInterface</code> is the binding piece between a <code>Machine</code> and a <code>Network</code>. A <code>NetworkInterface</code> references the <code>Network</code> it wants to join as well as the IPs it should use in that <code>Network</code>.</p> <p>The IPs (v4 / v6) can be specified in multiple ways:</p> <ul> <li>Without IPAM by specifying an IP literal</li> <li>As <code>ephemeral</code>, creating an <code>ipam.Prefix</code> with the prefix length of the specified ip family (32 / 128) that will be   owned and also deleted alongside the surrounding <code>NetworkInterface</code>. The name of the   created <code>ipam.Prefix</code> will be <code>&lt;nic-name&gt;-&lt;index&gt;</code>, where <code>&lt;index&gt;</code> is the index of the <code>ephemeral</code> in the <code>ips</code>   list. An existing <code>Prefix</code> with that name will not be used for the <code>NetworkInterface</code> to avoid using an unrelated   <code>Prefix</code> by mistake.</li> </ul> <p>When specifying IPs, a user should also specify <code>ipFamilies</code>. <code>ipFamilies</code> validates that there can be either a single <code>IPv4</code> / <code>IPv6</code>, or an ordered list of an <code>IPv4</code> / <code>IPv6</code> address. If left empty and it can be deducted deterministically from the <code>ips</code>, it will be defaulted. Same applies vice versa.</p> <p>The binding between a <code>NetworkInterface</code> and a <code>Machine</code> is bidirectional via <code>NetworkInterface.spec.machineRef.name</code> / <code>Machine.spec.networkInterfaces[*].name</code>. For the mvp, we will only allow exactly 1 <code>NetworkInterface</code> per <code>Machine</code> .</p> <p>Example usage:</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: NetworkInterface\nmetadata:\n  namespace: default\n  name: my-machine-interface\nspec:\n  networkRef:\n    name: my-network\n  ipFamilies: [IPv4, IPv6]\n  ips:\n#    - value: 10.0.0.1 # It is also possible to directly specify IPs without IPAM \n#    - value: 2607:f0d0:1002:51::4 # Same applies for v6 addresses\n    - ephemeral:\n        prefixTemplate:\n          spec:\n            prefixRef:\n              name: my-node-prefix-v4\n    - ephemeral:\n        prefixTemplate:\n          spec:\n            prefixRef:\n              name: my-node-prefix-v6\n  machineRef:\n    name: my-machine\nstatus:\n  ips: # This will be updated with the allocated addresses.\n    - 10.0.0.1\n    - 2607:f0d0:1002:51::4\n---\napiVersion: compute.api.onmetal.de/v1alpha1\nkind: Machine\nmetadata:\n  namespace: default\n  name: my-machine\n  labels:\n    app: web\nspec:\n  networkInterfaces:\n    - name: my-interface\n      networkInterfaceRef:\n        name: my-machine-interface\n  ...\nstatus:\n  networkInterfaces:\n    - name: my-interface\n      ips: # The machine reports all ips available via its interfaces\n        - 10.0.0.1\n        - 2607:f0d0:1002:51::4\n  ...\n</code></pre> <p>To simplify managing the creation of a <code>NetworkInterface</code> per <code>Machine</code>, a <code>Machine</code> can specify a <code>NetworkInterface</code> as <code>ephemeral</code>, creating and owning it before the <code>Machine</code> becomes available. The name of the <code>NetworkInterface</code> will be <code>&lt;machine-name&gt;-&lt;name&gt;</code> where <code>&lt;name&gt;</code> is the <code>name:</code> value in the <code>networkInterfaces</code> list. Existing <code>NetworkInterface</code>s will not be adopted by the <code>Machine</code>.</p> <p>Sample manifest:</p> <pre><code>apiVersion: compute.api.onmetal.de/v1alpha1\nkind: Machine\nspec:\n  interfaces:\n    - name: my-interface\n      ephemeral:\n        networkInterfaceTemplate:\n          spec:\n            ipFamilies: [IPv4, IPv6]\n            networkRef:\n              name: my-network\n            ips:\n              - ephemeral:\n                  prefixTemplate:\n                    spec:\n                      prefixRef:\n                        name: my-node-prefix-v4\n              - ephemeral:\n                  prefixTemplate:\n                    spec:\n                      prefixRef:\n                        name: my-node-prefix-v6\n  ...\n</code></pre>"},{"location":"proposals/01-networking-integration/#the-aliasprefix-type","title":"The <code>AliasPrefix</code> type.","text":"<p>An <code>AliasPrefix</code> allows routing a sub-prefix of a network to multiple targets (in our case, <code>NetworkInterface</code>s). It references its target <code>Network</code> and selects the <code>NetworkInterfaces</code> via its <code>selector</code> to apply the alias to.</p> <p>The <code>AliasPrefix</code> creates an <code>AliasPrefixRouting</code> object with the same name as itself where it maintains a list of the <code>NetworkInterface</code>s matching its <code>selector</code>. If the <code>selector</code> is empty it is assumed that an external process manages the <code>AliasPrefixRouting</code> belonging to that <code>AliasPrefix</code>.</p> <p>Example manifest:</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: AliasPrefix\nmetadata:\n  namespace: default\n  name: my-pod-prefix-1\nspec:\n  ipFamily: IPv4\n  networkRef:\n    name: my-network\n  networkInterfaceSelector:\n    matchLabels:\n      foo: bar\n  prefix:\n#    value: 10.0.0.0/24 # It's possible to directly specify the AliasPrefix value\n    ephemeral:\n      prefixTemplate:\n        spec:\n          prefixRef:\n            name: my-pod-prefix\n          prefixLength: 24\nstatus:\n  prefix: 10.0.0.0/24\n</code></pre> <p>This could manifest in the following <code>AliasPrefixRouting</code>:</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: AliasPrefixRouting\nmetadata:\n  namespace: default\n  name: my-pod-prefix-1\nnetworkRef:\n  name: my-network\ndestinations:\n  - name: my-machine-interface-1\n    uid: 2020dcf9-e030-427e-b0fc-4fec2016e73a\n  - name: my-machine-interface-2\n    uid: 2020dcf9-e030-427e-b0fc-4fec2016e73d\n</code></pre> <p>To simplify the creation and use of an <code>AliasPrefix</code> per <code>NetworkInterface</code>, a <code>NetworkInterface</code> allows the creation via <code>ephemeralAliasPrefixes</code>. The resulting <code>AliasPrefix</code> name will be <code>&lt;nic-name&gt;-&lt;name&gt;</code> where <code>&lt;name&gt;</code> is the name in the <code>ephemeralAliasPrefixes</code> list.</p> <p>It will also automatically be set in the same network and only target the hosting <code>NetworkInterface</code>. <code>selector</code> and <code>networkRef</code> in <code>spec</code> thus cannot be specified.</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: NetworkInterface\nmetadata:\n  namespace: default\n  name: my-machine-interface\nspec:\n  ephemeralAliasPrefixes:\n    - name: podrange-v4\n      spec:\n        prefix:\n#          value: 10.0.0.0/24 # It's possible to directly specify the AliasPrefix value\n          ephemeralPrefix:\n            spec:\n              prefixRef:\n                name: my-pod-prefix\n              prefixLength: 24\n</code></pre>"},{"location":"proposals/01-networking-integration/#the-virtualip-type","title":"The <code>VirtualIP</code> type","text":"<p>A <code>VirtualIP</code> requests a stable public IP for a single targets (<code>NetworkInterface</code>s). There is a <code>type</code> field that currently only can be <code>type: Public</code> in order to support other future <code>VirtualIP</code> types (for instance, <code>VirtualIP</code>s in other networks).</p> <p>As the public prefixes are provider-managed and custom public IP pools are not in scope of this draft, the IP allocation cannot be influenced and thus no construct like <code>prefixRef</code> is possible for <code>VirtualIP</code>s.</p> <p>To disambiguate between IPv4 and IPv6, the <code>VirtualIP</code> requires an <code>ipFamily</code> (same enum type as in Kubernetes' <code>Service.spec.ipFamilies</code>).</p> <p>The <code>VirtualIP</code> references the claiming <code>NetworkInterface</code> using <code>targetRef</code>.</p> <p>Example manifest:</p> <pre><code>apiVersion: networking.api.onmetal.de\nkind: VirtualIP\nmetadata:\n  namespace: default\n  name: my-virtual-ip\nspec:\n  type: Public\n  ipFamily: IPv4\n  targetRef:\n    name: my-nic\n    uid: 2020dcf9-e030-427e-b0fc-4fec2016e73d\nstatus:\n  ip: 45.86.152.88\n  phase: Bound\n</code></pre> <p>To simplify the creation and use of a <code>VirtualIP</code> per <code>NetworkInterface</code>, a <code>NetworkInterface</code> allows the creation via <code>virtualIP.ephemeral</code>. The resulting <code>VirtualPrefix</code> name will be <code>&lt;nic-name&gt;</code> It will also automatically be set up to reference the creating <code>NetworkInterface</code>. A <code>networkInterfaceRef</code> in the <code>spec</code> thus cannot be specified.</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: NetworkInterface\nmetadata:\n  namespace: default\n  name: my-machine-interface\nspec:\n  virtualIP:\n    ephemeral:\n      virtualIPTemplate:\n        spec:\n          type: Public\n          ipFamily: IPv4\n</code></pre>"},{"location":"proposals/01-networking-integration/#scenarios","title":"Scenarios","text":""},{"location":"proposals/01-networking-integration/#kubernetes-gardener-integration-on-top-of-onmetal","title":"Kubernetes (Gardener) integration on top of onmetal","text":"<p>For a Kubernetes integration, multiple worker nodes should be created in the same network. For each worker node, a separate pod prefix should be allocated. For internet-facing requests, each node should get a distinct public <code>VirtualIP</code> (in the future, outgoing requests will be solved via <code>SNAT</code>, but for the initial version of the MVP a <code>VirtualIP</code> is chosen).</p> <p>Additionally, to show it's possible, an <code>AliasPrefix</code> that is shared across different nodes is created.</p> <p>These are the required manifests:</p> <pre><code># IPAM Setup:\n# Create a root prefix and a pod / node sub-prefix.\napiVersion: ipam.api.onmetal.de/v1alpha1\nkind: Prefix\nmetadata:\n  namespace: default\n  name: root\nspec:\n  prefix: 10.0.0.0/8\n---\napiVersion: ipam.api.onmetal.de/v1alpha1\nkind: Prefix\nmetadata:\n  namespace: default\n  name: pods\nspec:\n  prefixLength: 11\n  parentRef:\n    name: root\n---\napiVersion: ipam.api.onmetal.de/v1alpha1\nkind: Prefix\nmetadata:\n  namespace: default\n  name: nodes\nspec:\n  prefixLength: 16\n  parentRef:\n    name: root\n---\n# Once IPAM is done, the concrete networking is defined\n# The Network is the bracket around all resources\napiVersion: networking.api.onmetal.de/v1alpha1\nkind: Network\nmetadata:\n  namespace: default\n  name: k8s\n---\n# Create one prefix that should be shared across all machines\napiVersion: networking.api.onmetal.de/v1alpha1\nkind: AliasPrefix\nmetadata:\n  namespace: default\n  name: shared\nspec:\n  networkRef:\n    name: k8s\n  networkInterfaceSelector:\n    matchLabels:\n      type: k8s-worker\n  prefix:\n    ephemeral:\n      prefixTemplate:\n        spec:\n          prefixRef:\n            name: k8s\n          prefixLength: 16\n---\n# Create the actual machine\napiVersion: compute.api.onmetal.de/v1alpha1\nkind: Machine\nmetadata:\n  namespace: default\n  name: worker-1\n  labels:\n    type: k8s-worker\nspec:\n  image: gardenlinux-k8s-worker:v0.23.5\n  networkInterfaces:\n    - name: primary\n      ephemeral:\n        networkInterfaceTemplate:\n          spec:\n            # Let the nic join the network\n            networkRef:\n              name: k8s\n            # The IP should be allocated from the node range\n            ips:\n              - ephemeral:\n                  prefixTemplate:\n                    spec:\n                      ipFamily: IPv4\n                      prefixRef:\n                        name: nodes\n            # Create a pod alias range exclusively for this machine\n            ephemeralAliasPrefixes:\n              - name: pods\n                spec:\n                  prefix:\n                    ephemeral:\n                      prefixTemplate:\n                        ipFamily: IPv4\n                        spec:\n                          prefixRef:\n                            name: pods\n                          prefixLength: 24\n            # Create a virtual IP for this machine\n            virtualIP:\n              - ephemeral:\n                  virtualIPTemplate:\n                    spec:\n                      type: Public\n                      ipFamily: IPv4\n</code></pre>"},{"location":"proposals/01-networking-integration/#alternatives","title":"Alternatives","text":"<p>None discussed so far.</p>"},{"location":"proposals/02-machine-console-access/","title":"02 machine console access","text":"<p>title: Machine Console Access</p> <p>oep-number: 2</p> <p>creation-date: 2022-12-05</p> <p>status: implementable|implemented</p> <p>authors:</p> <ul> <li>@adracus</li> </ul> <p>reviewers:</p> <ul> <li>@gehoern</li> <li>@afritzler</li> <li>@Gchbg</li> </ul>"},{"location":"proposals/02-machine-console-access/#oep-02-machine-console-access","title":"OEP-02: Machine Console Access","text":""},{"location":"proposals/02-machine-console-access/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/02-machine-console-access/#summary","title":"Summary","text":"<p>A user of the onmetal-api should be able to access the serial console of their machine to access / debug / run imperative commands on it. For this, an endpoint + client-side tooling has to be created as well as the server-side machinery.</p>"},{"location":"proposals/02-machine-console-access/#motivation","title":"Motivation","text":"<p>Users should be able to access / debug / run imperative commands on their machines. This gives immediate feedback on the state of the machine and is a required feature for our minimum viable product.</p>"},{"location":"proposals/02-machine-console-access/#goals","title":"Goals","text":"<ul> <li>Define an endpoint + client side tooling for machine console access</li> <li>Define a server-side interface machine pool providers have to implement in order to   support console access to their machines.</li> </ul>"},{"location":"proposals/02-machine-console-access/#non-goals","title":"Non-Goals","text":"<ul> <li>Due to the imperative nature of consoles, no declarative interface to consoles should be defined.</li> <li>Have consoles as a building piece of other parts of the onmetal-api.</li> </ul>"},{"location":"proposals/02-machine-console-access/#proposal","title":"Proposal","text":""},{"location":"proposals/02-machine-console-access/#user-facing-api","title":"User-facing API","text":"<p>The <code>compute.api.onmetal.de/Machine</code> resource is extended with an <code>exec</code> subresource. When connecting to that subresource, a websocket connection to the backing machine console should be opened. Supported HTTP methods for the <code>exec</code> call are <code>POST</code> and <code>GET</code> (in order to be able to do this from a browser as well).</p> <p>Example call to the Kubernetes API server hosting the aggregated API:</p> <p>```http request GET https:///apis/compute.api.onmetal.de/v1alpha1/namespaces//machines//exec <pre><code>### Server-Side API\n\nOnce the server receives such a request, it gets the `Machine` and looks up the `MachinePool` the `Machine`\nis running on. If the `Machine` does not exist or is not scheduled onto a `MachinePool`, an error is returned.\n\nAfter identifying the responsible `MachinePool`, it is retrieved and its `.status.addresses` field is inspected\nfor an address to call. The `.status.addresses` field does not exist yet and has to be updated in the onmetal-api.\nIt is the responsibility of the `MachinePool` implementor to report its endpoints in the `status`.\n\nFor reference on the address type, see\n[the Kubernetes node address type](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#nodeaddress-v1-core)\nwhich will be used as reference for designing the address type.\n\nExample manifest:\n\n```yaml\napiVersion: compute.api.onmetal.de/v1alpha1\nkind: MachinePool\nmetadata:\n  name: my-machine-pool\nspec:\n  providerID: my://machine-pool\nstatus:\n  addresses:\n    - address: 10.250.0.38\n      type: InternalIP\n    - address: my-machine-pool-host\n      type: ExternalDNS\n</code></pre> <p>Once an address has been identified, the onmetal API server calls the endpoint of the <code>MachinePool</code> provider with an <code>exec</code> request for the <code>Machine</code>. The resulting websocket connection is proxied through the onmetal API server to the user.</p> <p><code>http request GET https://&lt;machine-pool-adddress&gt;/apis/compute.api.onmetal.de/namespaces/&lt;namespace&gt;/machines/&lt;machine&gt;/exec</code></p> <p>Caution: This proposal does not include anything on authentication mechanisms yet. Implementors can already implement the endpoint but authentication will be added in the future.</p>"},{"location":"proposals/02-machine-console-access/#alternatives","title":"Alternatives","text":""},{"location":"proposals/03-loadbalancer/","title":"03 loadbalancer","text":"<p>title: Network Loadbalancer</p> <p>oep-number: 3</p> <p>creation-date: 2022-10-18</p> <p>status: implementable</p> <p>authors:</p> <ul> <li>@gehoern</li> <li>@adracus</li> </ul> <p>reviewers:</p> <ul> <li>@MalteJ</li> <li>@adracus</li> <li>@afritzler</li> <li>@guvenc</li> </ul>"},{"location":"proposals/03-loadbalancer/#oep-3-network-loadbalancer","title":"OEP-3: Network Loadbalancer","text":""},{"location":"proposals/03-loadbalancer/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> <li>Details</li> </ul> </li> <li>Proposal</li> </ul>"},{"location":"proposals/03-loadbalancer/#summary","title":"Summary","text":"<p>Load Balancing is an essential requirement in any modern network architecture. It makes backend services scalable, fault-tolerant and provides easy-to-consume access to external consumers.</p> <p>There are multiple types and strategies for load balancing: IP-based load balancing (L3 in the OSI model), Port-based load balancing (L4) and application-based load balancing (L7). This proposal focuses on IP-based load balancers, since they can be used as a foundation for the higher level load balancer types.</p>"},{"location":"proposals/03-loadbalancer/#motivation","title":"Motivation","text":"<p>A <code>VirtualIP</code> (OEP-1) allows to expose a <code>NetworkInterface</code> with a stable public IP. Services running on a <code>Machine</code> using that <code>NetworkInterface</code> can be consumed this way. However, if the <code>Machine</code> or the service running on that <code>Machine</code> crashes, the service will have an outage. To be more resilient and to scale beyond single <code>NetworkInterface</code>s, a <code>LoadBalancer</code> allows targeting multiple <code>NetworkInterface</code>s and distributes traffic between them.</p>"},{"location":"proposals/03-loadbalancer/#goals","title":"Goals","text":"<ul> <li>Define an API for managing L3 load balancers with publicly available addresses</li> <li>Load balancers should allow specifying their IP stack (<code>IPv4</code> / <code>IPv6</code> / dual stack). Public IP addresses   should be allocated according to the specified IP stack.</li> <li>Load balancers should support multiple target <code>NetworkInterface</code>s (   see (OEP-1)</li> <li>The load balancer should dynamically watch for target <code>NetworkInterface</code>s.</li> <li>All target <code>NetworkInterface</code>s must be in the same <code>Network</code>.</li> <li>The load balancer should be able to filter unwanted traffic. The filtering must not alter the packages.   The following filters should be implemented:<ul> <li>Filter depending on ports &amp; protocols (UDP/TCP/SCTP).</li> <li>ICMP requests should be filtered out by default.</li> </ul> </li> <li>Load balancing must be transparent for both target and source.</li> </ul>"},{"location":"proposals/03-loadbalancer/#non-goals","title":"Non-Goals","text":"<ul> <li>No address or port translation / rewriting (no SNAT / DNAT) (L4 Loadbalancer) support</li> <li>No injection of additional information (e.g. x-forwarded-for) (L7 Loadbalancer) support</li> <li>No protocol offloading like ssl (L7 Loadbalancer) support</li> <li>If more load balancer IPs are required than a single load balancer serves, more load balancers have to be requested.</li> </ul>"},{"location":"proposals/03-loadbalancer/#details","title":"Details","text":"<ul> <li>Load balancing is used to deliver a packet addressed to the load balancer to one of its targets via the onmetal   network routing</li> <li>The target needs to be aware of the load balancer's IP and needs to answer with it (and to receive traffic with it)</li> <li>Answers to the request will be directly delivered since all details are known by the target</li> </ul>"},{"location":"proposals/03-loadbalancer/#proposal","title":"Proposal","text":"<p>Introduce a <code>LoadBalancer</code> resource that dynamically selects multiple target <code>NetworkInterface</code>s via a <code>networkInterfaceSelector</code> <code>metav1.LabelSelector</code> (as e.g. in <code>AliasPrefix</code>es). The <code>LoadBalancer</code> of <code>type: Public</code> should allocate public IPs for its <code>ipFamilies</code> and announce them in its <code>status.ips</code>. <code>ports</code> defines an allow list of which traffic should be handled by a <code>LoadBalancer</code>. A <code>port</code> consists of a <code>protocol</code>, <code>port</code> and an optional <code>portEnd</code> to support port range filtering. <code>networkRef</code> defines the target <code>Network</code> a <code>NetworkInterface</code> has to be in in order to be an eligible target for traffic forwarding (see OEP-1).</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: LoadBalancer\nmetadata:\n  namespace: default\n  name: my-load-balancer\nspec:\n  # type denotes which kind of load balancer to create. For now, only `Public` is supported.\n  type: Public\n  # ip families specifies the supported IP stack of a load balancer. May be `IPv4`, `IPv6` or both (dual stack).\n  ipFamilies: [ IPv4, IPv6 ]\n  # ports is an allow list of traffic to load balance via port(range) and protocol.\n  ports:\n    - # protocols supported UDP, TCP, SCTP\n      protocol: tcp\n      # single port\n      port: 80\n    - protocol: udp\n      # port range\n      port: 1024\n      portEnd: 2048\n  # networkRef specifies the target network any target network interface should be in.\n  networkRef:\n    name: my-network\n  # network interface selector specifies the network interfaces to select for load balancing.\n  networkInterfaceSelector:\n    matchLabels:\n      key: db\n      foo: bar\nstatus:\n  # ips are the ips allocated for the load balancer.\n  ips:\n    - 45.86.152.88\n    - 2001::\n</code></pre>"},{"location":"proposals/03-loadbalancer/#routing-state-object","title":"Routing State Object","text":"<p>The load balancer needs details computable at the onmetal API level to describe the explicit targets in a pool traffic is routed to. <code>LoadBalancerRouting</code> describes <code>NetworkInterface</code>s load balanced traffic is routed to. This object describes a state of the <code>LoadBalancer</code> and results of the <code>LoadBalancer</code> definition specifically <code>networkInterfaceSelector</code> and <code>networkRef</code>. <code>LoadBalancerRouting</code> is reconciled by the <code>onmetal-api</code> load balancer controller.</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: LoadBalancerRouting\nmetadata:\n  namespace: default\n  name: my-load-balancer # Same name as the load balancer it originates from.\n# networkRef references the exact network object the routing belongs to.\nnetworkRef:\n  name: my-network\n# destinations lists the target network interface instances (including UID) for load balancing.\ndestinations:\n  - name: my-machine-interface-1\n    uid: 2020dcf9-e030-427e-b0fc-4fec2016e73a\n  - name: my-machine-interface-2\n    uid: 2020dcf9-e030-427e-b0fc-4fec2016e73d\n</code></pre>"},{"location":"proposals/04-nat-gateway/","title":"04 nat gateway","text":"<p>title: NAT Gateway</p> <p>oep-number: 4</p> <p>creation-date: 2022-18-10</p> <p>status: implementable</p> <p>authors:</p> <ul> <li>@gehoern</li> <li>@adracus</li> </ul> <p>reviewers:</p> <ul> <li>@MalteJ</li> <li>@adracus</li> <li>@afritzler</li> <li>@guvenc</li> </ul>"},{"location":"proposals/04-nat-gateway/#oep-4-cloud-nate-gateway","title":"OEP-4: Cloud Nate Gateway","text":""},{"location":"proposals/04-nat-gateway/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> </ul>"},{"location":"proposals/04-nat-gateway/#summary","title":"Summary","text":"<p>NAT gateways are essential for safe and resource-efficient internet access. Any machine (even those with no public / virtual IP) using a NAT gateway can access the internet without being directly exposed. IPs belonging to the NAT gateway are shared between multiple clients. Communication initiated by a member can get answers from outside (connection tracking) but the member cannot be contacted (no remote initiated traffic) from outside.</p>"},{"location":"proposals/04-nat-gateway/#motivation","title":"Motivation","text":"<p>A <code>NetworkInterface</code>s may have no dedicated public IP addresses (no <code>VirtualIP</code> via <code>spec.virtualIP</code>) but still may need public internet access. A NAT gateway provides this functionality by defining a default gateway to the network interface and a NAT for incoming and outgoing traffic (e.g. downloading container images). The <code>NetworkInterface</code> thus can reach the public internet but is not exposed as it would be when using a <code>VirtualIP</code>.</p>"},{"location":"proposals/04-nat-gateway/#goals","title":"Goals","text":"<ul> <li>A public NAT gateway should only target a single <code>Network</code>.</li> <li>Define an API for managing NAT gateways with publicly available addresses.</li> <li>Define the maximum ports of a NAT gateway to be used by a target <code>NetworkInterface</code>.</li> <li>Define the name of the <code>Network</code> and the <code>NetworkInterface</code> the NAT gateway is operating on.</li> </ul>"},{"location":"proposals/04-nat-gateway/#non-goals","title":"Non-Goals","text":"<ul> <li>The NAT gateway is not transparent since it manipulates the source port for outgoing traffic towards the remote   target.</li> </ul>"},{"location":"proposals/04-nat-gateway/#proposal","title":"Proposal","text":"<p>Introduce a <code>NATGateway</code> resource that targets <code>NetworkInterface</code>s in a <code>Network</code>. The <code>Network</code> is specified via a <code>networkRef</code>, the <code>NetworkInterface</code>s are targeted via a <code>LabelSelector</code>. During reconciliation, only <code>NetworkInterface</code>s that are not yet exposed via <code>VirtualIP</code> are selected and will be NATed and get masqueraded internet access. To denote a <code>NATGateway</code> as publicly facing, <code>type: Public</code> must be specified. For now, this is the only supported type. A <code>NATGateway</code> must specify the IP stack it operates on via <code>ipFamilies</code>. This can be <code>IPv4</code>, <code>IPv6</code> or both ( dual-stack). The <code>ips</code> field names the ips allocated for a <code>NATGateway</code>. If <code>ipFamilies</code> is dual-stack, both an <code>IPv4</code> and <code>IPv6</code> ip address will be allocated for each item in the <code>ips</code> field. The field <code>portsPerNetworkInterface</code> defines the maximum number of concurrent connections from a single <code>NetworkInterface</code> to a remote IP. The current usage of ports is reported in <code>status.portsUsed</code>.</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: NATGateway\nmetadata:\n  namespace: default\n  name: my-nat\nspec:\n  # Type denotes the type of nat gateway. For now, only 'Public' is supported.k:w\n  type: Public\n  # ip families specifies the supported IP stack of a load balancer. May be `IPv4`, `IPv6` or both (dual stack).\n  ipFamilies: [ IPv4, IPv6 ]\n  # the network the nat gateway targets.\n  networkRef:\n    name: sample-network\n  # ips are the ips to allocate for the nat gateway.\n  # If dual-stack is active, at least two ips will be allocated.\n  ips:\n    - name: ip1\n  # defines the concurrent connections per NetworkInterface and target. Must be a power of 2.\n  portsPerNetworkInterface: 64\n  # networkInterfaceSelector selects the target network interfaces that should be NATed.\n  networkInterfaceSelector:\n    matchLabels:\n      key: db\n      foo: bar\nstatus:\n  # ips lists the ips allocated for each requested ip.\n  ips:\n    - name: ip1\n      ips:\n      - 48.86.152.12\n  # portsUsed reports the current port usage of the nat gateway.\n  portsUsed: 128 # Equal to portsPerNetworkInterface * entries in routing destinations\n</code></pre>"},{"location":"proposals/05-object-storage/","title":"05 object storage","text":"<p>title: Object Storage</p> <p>oep-number: 5</p> <p>creation-date: 2022-12-19</p> <p>status: implementable</p> <p>authors:</p> <ul> <li>@lukasfrank</li> <li>@gehoern</li> </ul> <p>reviewers:</p> <ul> <li>@adracus</li> <li>@MalteJ</li> </ul>"},{"location":"proposals/05-object-storage/#oep-5-object-storage","title":"OEP-5: Object Storage","text":""},{"location":"proposals/05-object-storage/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/05-object-storage/#summary","title":"Summary","text":"<p>Object storage builds the basis for many cloud applications. An Object Storage provides a simplified object  model for files, but has a reduced set of security and access features (non-posix). This functionality is built on top  of the HTTP protocol. The current market standard is S3.  This document describes how to integrate simplified S3 buckets into the OnMetal API without taking too many details of  the S3 feature completeness itself.</p>"},{"location":"proposals/05-object-storage/#motivation","title":"Motivation","text":"<p>Object Storage is demanded by cloud native applications, therefore, OnMetal needs to provide it for a complete solution. The Object Storage service should be integrated into OnMetal and is not designed  to be just a service on top of OnMetal. The used protocol is called S3 which introduces a storage entity called bucket. For the beginning only the bucket creation and removal is covered.</p>"},{"location":"proposals/05-object-storage/#goals","title":"Goals","text":"<ul> <li>S3-compatible object storage implementation</li> <li>Automatic assigned public storage endpoint </li> <li>Providing a REST-API endpoint to address the bucket</li> </ul>"},{"location":"proposals/05-object-storage/#non-goals","title":"Non-Goals","text":"<ul> <li>Support other object storage protocols than S3</li> <li>Internal buckets (reachable only from inside the cluster)</li> <li>Quota handling (size or object number limitation)</li> <li>External Object level access control (beyond what the S3 implementation provides)</li> </ul>"},{"location":"proposals/05-object-storage/#proposal","title":"Proposal","text":"<p>The proposal to provide an Object Storage consists of three API resources: <code>Bucket</code>, <code>BucketClass</code> and <code>BucketPool</code>.  A <code>Bucket</code> is the S3 enabled storage endpoint. IOPS/Bandwidth limitations are controlled via a <code>BucketClass</code> and the  capabilities of the underlying storage provider are expressed via a <code>BucketPool</code>. A <code>Bucket</code> can be requested  from a <code>BucketPool</code> as long as it can provide the performance characteristics described in the <code>BucketClass</code>.  The proposed API resources are similar to <code>Volume</code>, <code>VolumeClass</code> and <code>Volumepool</code> except that a volume is a  block device with a specific driver.</p>"},{"location":"proposals/05-object-storage/#bucket","title":"Bucket","text":"<p>A <code>Bucket</code> is a namespaced resource to request S3-compatible object storage. The desired <code>BucketClass</code> is referenced by the <code>bucketClassRef</code>. If no pool is pre-defined,  the <code>bucketPoolSelector</code> will be used to find a suitable <code>BucketPool</code>.  The desired pool, either pre-defined or  set by another controller, is stated in the <code>bucketPoolRef</code>.</p> <p>The information to access the requested <code>Bucket</code> is in the <code>access</code> field of the status.  The <code>endpoint</code> defines the address of the <code>Bucket</code> Rest-API. Access credentials are placed in a secret with is referenced  through the <code>secretRef</code>. The <code>state</code> indicates if the <code>Bucket</code> is <code>Available</code>, <code>Pending</code> or in an <code>Error</code> state.</p> <pre><code>apiVersion: storage.api.onmetal.de/v1alpha1\nkind: Bucket\nmetadata:\n  name: bucket-1\nspec:\n  bucketClassRef:\n    name: slow\n  bucketPoolSelector:\n    matchLabels:\n      key: db\n      foo: bar\n  bucketPoolRef:\n    name: fra-shared\nstatus:\n  access:\n    endpoint: foo.bar.example.org \n    secretRef:\n      name: 000225194345f27a40257c5777c96a03ce219f96731f22afc45b7dfda7d077d\n  state: Available\n</code></pre>"},{"location":"proposals/05-object-storage/#bucketclass","title":"BucketClass","text":"<p>A <code>BucketClass</code> is a non-namespaced resource which describes the characteristics of a <code>Bucket</code>. The maximal  performance the <code>Bucket</code> will offer (like I/O operations or throughput) is defined in the <code>capabilities</code> field.</p> <pre><code>apiVersion: storage.api.onmetal.de/v1alpha1\nkind: BucketClass\nmetadata:\n  name: slow\ncapabilities:\n  iops: 10\n  tps: 20Mi\n</code></pre>"},{"location":"proposals/05-object-storage/#bucketpool","title":"BucketPool","text":"<p>A <code>BucketPool</code> is a non-namespaced logical unit and accommodates a collection of <code>Bucket</code>s.  The <code>provider</code>'s id (the implementor's id) of the <code>BucketPool</code> is stated in the <code>providerID</code> field.  Only <code>Bucket</code>s who tolerate all the taints, will land in the <code>BucketPool</code>. <code>BucketClasses</code> which can be fulfilled by  the provider of the <code>BucketPool</code>, are listed in the status field <code>availableBucketClasses</code>. The <code>state</code> in the status  indicates if the pool is <code>Available</code>, <code>Pending</code> or <code>Unavailable</code>.</p> <pre><code>apiVersion: storage.api.onmetal.de/v1alpha1\nkind: BucketPool\nmetadata:\n  name: ceph-object-store\nspec:\n  providerID: cephlet://pool\n  taints: []\nstatus:\n  availableBucketClasses:\n    - name: fast\n    - name: slow\n  state: Available\n</code></pre>"},{"location":"proposals/05-object-storage/#alternatives","title":"Alternatives","text":""},{"location":"proposals/06-storage-encryption/","title":"OEP-6: Storage Encryption","text":""},{"location":"proposals/06-storage-encryption/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> </ul>"},{"location":"proposals/06-storage-encryption/#summary","title":"Summary","text":"<p>One of the important feature of Cloud Native IaaS is to provide secure storage. This proposal focuses on providing option to enable encryption for individual onmetal Volume.</p>"},{"location":"proposals/06-storage-encryption/#motivation","title":"Motivation","text":"<p>As part of Storage encryption feature Onmetal API supports option to enable encryption of Volumes. Volume level encryption helps protect users from data theft or accidental loss, by rendering data stored on hard drives unreadable when an unauthorized user tries to gain access. The loss of encryption keys is a major concern, as it can render any encrypted data useless. </p>"},{"location":"proposals/06-storage-encryption/#goals","title":"Goals","text":"<ul> <li>Allow user to enable volume encryption by providing encryption key via secret reference</li> </ul>"},{"location":"proposals/06-storage-encryption/#non-goals","title":"Non-Goals","text":"<ul> <li>Add a new attribute to provide source of encryption key like None/UserProvidedKey/DefaultMasterKey</li> <li>Add KMS support to manage user provided encryption keys</li> </ul>"},{"location":"proposals/06-storage-encryption/#proposal","title":"Proposal","text":"<ul> <li>The proposal introduces a new field <code>encryption</code> with currently the single attribute <code>secretRef</code>, referencing a secret to use for encryption, in existing <code>Volume</code> type. </li> <li><code>encryption</code> is an optional field.</li> <li>If <code>encryption</code> field is not provided by user, then onmetal <code>Volume</code> remains unencrypted</li> <li>To encrypt onmetal <code>Volume</code>, user has to first create kubernetes secret of Opaque type with key-value pair as below:<ul> <li>key = <code>encryptionKey</code> </li> <li>value = base64-encoded 256 bit encryption key</li> </ul> </li> <li>Then provide this secret name to <code>encryption.secretRef</code> attribute of <code>Volume</code> type.</li> </ul> <p>Secret for encryption key</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: encryption-key-secret\n  namespace: default\ntype: Opaque\ndata:\n  encryptionKey: QW9zejI4Y0xIR3pjR3M2UGltdHZVSnVSSGt6aWZiVTU4V3NIZElIL09idz0=\n</code></pre> <p>Volume with encryption key secret reference:</p> <pre><code>apiVersion: storage.api.onmetal.de/v1alpha1\nkind: Volume\nmetadata:\n  name: sample-volume\n  namespace: default\nspec:\n  volumeClassRef:\n    name: fast\n  volumePoolRef:\n    name: ceph\n  resources:\n    storage: 1Gi\n  encryption:\n    secretRef: encryption-key-secret\n</code></pre>"},{"location":"proposals/07-quota/","title":"07 quota","text":"<p>title: Quota</p> <p>oep-number: 7</p> <p>creation-date: 2023-01-19</p> <p>status: implementable</p> <p>authors:</p> <ul> <li>@adracus</li> </ul> <p>reviewers:</p> <ul> <li>@afritzler</li> <li>@gehoern</li> <li>@ManuStoessel</li> </ul>"},{"location":"proposals/07-quota/#oep-7-quota","title":"OEP-7: Quota","text":""},{"location":"proposals/07-quota/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/07-quota/#summary","title":"Summary","text":"<p>Quota is a mechanism to manage and limit the usage of resources across multiple requesting entities. By introducing quotas, a system can be protected from usage spikes and services can be kept responsive. Quotas also can ensure that each requesting entity can exercise its right to a fair share of the resources.</p>"},{"location":"proposals/07-quota/#motivation","title":"Motivation","text":"<p>Kubernetes Resource Quotas are a great way to limit resource consumption for core Kubernetes types (allowing to manage things like overall CPU consumption) and resource count for all types. However, when it comes to limiting resource usage for custom types (in this special case, the <code>onmetal-api</code> types), the Kubernetes Quota system falls short of providing means to do so.</p> <p>For <code>onmetal-api</code> it should be possible to limit the actual requested resources like the total number of used CPUs, storage and memory as well as limit the count of resources by a given dimension (e.g. number of <code>Machine</code>s for a given <code>MachineClass</code>).</p>"},{"location":"proposals/07-quota/#goals","title":"Goals","text":"<ul> <li>Limit resource count in a <code>Namespace</code> (by dimension)</li> <li>Limit accumulated resource usage in a <code>Namespace</code> (by dimension)</li> <li>Integrate nicely into the existing Kubernetes <code>ResourceQuota</code> concepts</li> </ul>"},{"location":"proposals/07-quota/#non-goals","title":"Non-Goals","text":"<ul> <li>Limit resource count / accumulated resource usage cross-<code>Namespace</code></li> <li>Define a system to request quota increases</li> <li>Define a user management system</li> <li>Couple resource quota to any user system</li> </ul>"},{"location":"proposals/07-quota/#proposal","title":"Proposal","text":"<p>Introduce a new namespaced type <code>ResourceQuota</code> in the new <code>core</code> group. A <code>ResourceQuota</code> allows defining hard resource limits that cannot be exceeded. The limits are defined via <code>spec.hard</code> as a <code>corev1alpha1.ResourceList</code>. The currently enforced limits are shown in <code>status.hard</code> and the currently used limits in <code>status.used</code>. Requests to create / update resources that would exceed the quota will fail with the HTTP status code <code>403 Forbidden</code>.</p>"},{"location":"proposals/07-quota/#compute-resource-quota","title":"Compute Resource Quota","text":"<p>For the <code>onmetal-api</code> <code>compute</code> group, the following resources can be limited:</p> Resource Name Description requests.cpu Across all machines in non terminal state, the sum of cpus cannot exceed this value requests.memory Across all machines in non terminal state, the sum of memory cannot exceed this value"},{"location":"proposals/07-quota/#storage-resource-quota","title":"Storage Resource Quota","text":"<p>For the <code>onmetal-api</code> <code>storage</code> group, the following</p> Resource Name Description requests.storage Across all volumes in non terminal state, the sum of storage cannot exceed this value"},{"location":"proposals/07-quota/#object-count-quota","title":"Object Count Quota","text":"<p>Similar to Kubernetes' object count quota, it is possible to limit the number of resources per types using the following syntax: <code>count/&lt;resource&gt;.&lt;group&gt;</code>. For example, <code>count/machines.compute.api.onmetal.de</code> would limit the number of machines from the <code>onmetal-api</code> <code>compute.api.onmetal.de</code> group.</p>"},{"location":"proposals/07-quota/#quota-scopes","title":"Quota Scopes","text":"<p>To measure / limit usage only for a subset of all resources, a <code>ResourceQuota</code> may specify a <code>scopeSelector</code>. A <code>scopeSelector</code> may contain multiple expressions and only matches a resource if it matches the intersection of enumerated scopes.</p> Scope Description MachineClass Match machines that reference the specified machine class VolumeClass Match volumes that reference the specified volume class <p>By using certain <code>scopeSelector</code>s, the quota can only track a specific set of resources. E.g. for the <code>MachineClass</code> <code>scopeSelector</code>, only <code>Machine</code>s can be tracked.</p>"},{"location":"proposals/07-quota/#example-manifests","title":"Example Manifests","text":"<p>Limit the accumulated amount of <code>cpu</code>, <code>memory</code> and <code>storage</code> across all <code>Machine</code>s and <code>Volume</code>s:</p> <pre><code>apiVersion: core.api.onmetal.de/v1alpha1\nkind: ResourceQuota\nmetadata:\n  name: limit-accumulated-usage\nspec:\n  hard:\n    requests.cpu: \"1000\"\n    requests.memory: 200Gi\n    requests.storage: 10Ti\n</code></pre> <p>Limit the number of machines for a given machine class:</p> <pre><code>apiVersion: core.api.onmetal.de/v1alpha1\nkind: ResourceQuota\nmetadata:\n  name: limit-large-machines\nspec:\n  hard:\n    count/machines.compute.api.onmetal.de: 10\n  scopeSelector:\n    matchExpressions:\n    - scopeName: MachineClass\n      operator: In\n      values:\n        - large\n</code></pre>"},{"location":"proposals/08-internal-load-balancer/","title":"OEP-8: Internal Load Balancers","text":""},{"location":"proposals/08-internal-load-balancer/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation</li> <li>Goals</li> <li>Non-Goals</li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/08-internal-load-balancer/#summary","title":"Summary","text":"<p>When developing services in the cloud, not all services should be available to the public internet. Nevertheless they need to be highly available within a certain network boundary.</p> <p>To solve this issue, other public cloud vendors allow defining internal load balancers.</p> <p>Internal load balancers behave much like their external / public counterparts with the important difference of not exposing the selected service to the public internet.</p>"},{"location":"proposals/08-internal-load-balancer/#motivation","title":"Motivation","text":"<p>In <code>onmetal-api</code>, we need to be able to make services highly available internally. Currently, we can only allocate IP addresses for <code>NetworkInterface</code>s and target them, however, as soon as the backing <code>Machine</code> fails, the service would become unavailable.</p> <p>To prevent this, we have to extend our current <code>LoadBalancer</code> type to also function internally. This should be done with a similar API as for the public use case but allow for the same flexibility with internal IPs as we have already with the <code>NetworkInterface</code> type.</p>"},{"location":"proposals/08-internal-load-balancer/#goals","title":"Goals","text":"<ul> <li> <p>Make a service running on multiple <code>Machine</code>s / <code>NetworkInterface</code>s in a single <code>Namespace</code>   available behind a load-balanced IP without exposing it outside their <code>Network</code></p> </li> <li> <p>Manage the used internal IPs either via literals or by using <code>ipam.Prefix</code>es.</p> </li> <li> <p>Extend the current <code>LoadBalancer</code> type with <code>type: Internal</code> indicating its use as an internal   load balancer.</p> </li> </ul>"},{"location":"proposals/08-internal-load-balancer/#non-goals","title":"Non-Goals","text":"<ul> <li> <p>Cross-Namespace consumption of the <code>LoadBalancer</code> - An internal <code>LoadBalancer</code> is only   available within one <code>Network</code></p> </li> <li> <p>Cross-Namespace IP allocation - IPs and prefixes are created and deleted in a single namespace.</p> </li> <li> <p>Use <code>VirtualIP</code>s in a <code>LoadBalancer</code> of <code>type: Internal</code>:   <code>VirtualIP</code>s are always public (compare to AWS' <code>ElasticIP</code>) and their IP allocation differs   from allocating internal IPs (that don't have to be publicly routable / announced via ASN).   If a user always wants the same internal IP, this use case is already covered by specifying a   literal IP value or by referencing an <code>ipam.Prefix</code>.</p> </li> </ul>"},{"location":"proposals/08-internal-load-balancer/#proposal","title":"Proposal","text":"<p>Example manifest:</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: LoadBalancer\nmetadata:\n  name: my-loadbalancer\nspec:\n  type: Internal\n  networkRef:\n    name: my-network\n  ipFamilies: [IPv4, IPv6]\n  ips:\n  - ip: 10.0.0.1 # It is possible to specify a literal IP\n  - ephemeral: # Or to allocate using an existing ipam.Prefix\n      prefixTemplate:\n        spec:\n          prefixRef: # The prefix length will always = IPFamily.Bits\n            name: my-lb-prefix-v6\n  networkInterfaceSelector:\n    matchLabels:\n      app: web\n  ports: # The port filtering is the same as for public load balancers\n  - protocol: TCP\n    port: 8080\nstatus:\n  ips:\n  - ip: \"10.0.0.1\"\n  - ip: \"2607:f0d0:1002:51::4\"\n</code></pre>"},{"location":"proposals/08-internal-load-balancer/#alternatives","title":"Alternatives","text":"<ul> <li> <p>Target multiple <code>NetworkInterface</code>s + IPs and track (e.g. via discovery / concensus protocol)   which of these are available to solve the high-availability aspect. This has the drawback of   high implementation effort + having to choose from multiple IPs / putting the burden of choosing   the correct IP on a potential consumer.</p> </li> <li> <p>Create <code>Machine</code>(s) that e.g. run <code>HAProxy</code> to target your services with. This comes with the   drawback of having to manage the <code>Machine</code>s / having multiple IPs for the load balancing machines   to choose from (see alternative 1).</p> </li> </ul>"},{"location":"proposals/09-network-peering/","title":"OEP-9: Network Peering","text":""},{"location":"proposals/09-network-peering/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/09-network-peering/#summary","title":"Summary","text":"<p>Network peering is a technique used to interleave two isolated networks, allowing members of both networks to communicate with each other as if they were in the same networking domain. This proposal describes how to introduce network peering to <code>onmetal-api</code>, building upon the existing concepts that were proposed in the Networking Integration OEP.</p>"},{"location":"proposals/09-network-peering/#motivation","title":"Motivation","text":"<p>Network peering allows members of two networks to communicate with each other without exposing them publicly and without a single point of failure. The networking fabric underneath is used to enable the actual routing. <code>onmetal</code>'s <code>networking</code> API should offer a way to define such a peering.</p>"},{"location":"proposals/09-network-peering/#goals","title":"Goals","text":"<ul> <li>Allow two <code>Network</code>s to communicate with each other without exposing their   routes / addresses publicly and by only using network routing to do so   (i.e. no load-balancing).</li> <li>Be less resource-intensive than comparable solutions like load-balancing /   VPN overlays.</li> </ul>"},{"location":"proposals/09-network-peering/#non-goals","title":"Non-Goals","text":"<ul> <li>Map / transform IP addresses: The peered networks will be interleaved with   each other without any transformation. The owners of the networks are   responsible for keeping the addresses conflict-free. If there are conflicts,   it is up to the networking implementation how to resolve them (e.g. use   a 'local-first' approach for which address / route to use).</li> </ul>"},{"location":"proposals/09-network-peering/#proposal","title":"Proposal","text":"<p>Extend the <code>networking.api.onmetal.de.Network</code> resource with a <code>spec.peerings</code> field that specifies the desired network peerings and a <code>status.peerings</code> that reflects the status of these peerings.</p> <p>A peering has a <code>name</code> as handle &amp; primary key (used in <code>StrategicMergePatch</code> and <code>Apply</code>). It references the network to peer with via a <code>networkRef</code> field. This <code>networkRef</code> contains the <code>name</code> and the <code>uid</code> of the target network. If the <code>uid</code> is unset, the <code>Network</code> controller sets this to the <code>uid</code> of the corresponding network upon first reconciliation. This ensures that the same object instances are peered together by verifying the object identity.</p> <p>Both <code>Network</code>s have to specify a matching peering item (i.e. reference each other via <code>networkRef</code>) to mutually accept the peering.</p> <p>The (binding) <code>phase</code> of a <code>spec.peerings</code> item is reflected in a corresponding <code>status.peerings</code> item with the same <code>name</code>. The <code>phase</code> can either be <code>Pending</code>, meaning there is no active peering, or <code>Bound</code>, meaning the peering as described in the <code>spec.peerings</code> item is in place. The <code>lastTransitionTime</code> field is updated every time there is a change in the <code>phase</code>, allowing users and external controllers to determine whether a binding is hanging and to manually delete it if necessary.</p> <p>Example Manifests:</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: Network\nmetadata:\n  name: my-network-1\n  uid: 2020dcf9-e030-427e-b0fc-4fec2016e73a\nspec:\n  peerings:\n  # name is the name of the peering configuration\n  - name: my-network-peering\n    networkRef:\n      name: my-network-2\n      # If unset, uid will be filled in by the Network controller\n      # uid: 3030dcf9-f031-801b-f0f0-4fec2016e73a\nstatus:\n  peerings:\n  - name: my-network-peering\n    # The phase shows the binding progress between two networks.\n    # The initial state is 'Pending' until both peers accept.\n    phase: Bound\n    lastPhaseTransitionTime: \"2023-02-16T15:06:58Z\"\n---\napiVersion: networking.api.onmetal.de/v1alpha1\nkind: Network\nmetadata:\n  name: my-network-2\n  uid: 3030dcf9-f031-801b-f0f0-4fec2016e73a\nspec:\n  # Both networks have to have the semantically same peering configuration.\n  peerings:\n  - name: my-network-peering\n    networkRef:\n      name: my-network-1\n      # If unset, uid will be filled in by the Network controller\n      # uid: 2020dcf9-e030-427e-b0fc-4fec2016e73a\nstatus:\n  peerings:\n  - name: my-network-peering\n    phase: Bound\n    lastPhaseTransitionTime: \"2023-02-16T15:06:58Z\"\n</code></pre> <p>Network peering can also specify <code>Network</code>s from different namespaces. For this, the <code>networkRef</code> field includes a <code>namespace</code> field (default empty if in the same namespace). Both <code>Network</code>s need to reference the other network and namespace correctly, otherwise the peering will stay in <code>phase: Pending</code> indefinitely.</p> <p>Example Manifests:</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: Network\nmetadata:\n  namespace: ns-1\n  name: my-network-1\nspec:\n  peerings:\n  - name: my-network-peering\n    networkRef:\n      namespace: ns-2\n      name: my-network-2\n---\napiVersion: networking.api.onmetal.de/v1alpha1\nkind: Network\nmetadata:\n  namespace: ns-2\n  name: my-network-2\nspec:\n  peerings:\n  - name: my-network-peering\n    networkRef:\n      namespace: ns-1\n      name: my-network-1\n</code></pre>"},{"location":"proposals/09-network-peering/#alternatives","title":"Alternatives","text":"<ul> <li>Create a VPN overlay between two networks. However, this requires a (potentially   public endpoint and introduces points of failure in form of the VPN server(s)   and client(s). Additionally, the VPN components have to be maintained manually.</li> <li>Use hole-punching to create a bidirectional tunnel. This cannot always be done,   as it depends on the network fabric, requires a publicly available   rendezvous-point, introduces potential points of failure and requires   maintenance for its components as for the VPN-based solution.</li> <li>Depending on the use-case, services can be exposed behind an internal   load-balancer, providing failure-safe and scalable communication channels.</li> </ul>"},{"location":"proposals/10-network-policies/","title":"OEP-10: Network Policies","text":""},{"location":"proposals/10-network-policies/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/10-network-policies/#summary","title":"Summary","text":"<p>In an unregulated network, it is impossible to properly enforce the rules of least-privilege. Each member of a network could potentially communicate to each other, receive traffic from the public internet (if connected) and communicate with the public internet (if connected). This imposes a big security risk which has to be properly addressed in each modern infrastructure. This proposal describes how to introduce network policies as a means to regulate traffic inside a network building upon the existing concepts that were proposed in the Networking Integration OEP.</p>"},{"location":"proposals/10-network-policies/#motivation","title":"Motivation","text":"<p>Currently, there is no way to describe which members of a network should be able to communicate with each other. Same applies to traffic coming from the public internet / going to the public internet. The <code>onmetal-api</code> should be extended with traffic control mechanisms, allowing to limit / deny traffic on a per-instance basis. Of course, the mechanisms should align well with existing proposals / concepts in the Kubernetes world.</p>"},{"location":"proposals/10-network-policies/#goals","title":"Goals","text":"<ul> <li>Be able to deny ingress and egress traffic between members of a <code>Network</code>.</li> <li>Be able to deny ingress and egress traffic between members of a <code>Network</code> and   the public internet.</li> </ul>"},{"location":"proposals/10-network-policies/#non-goals","title":"Non-Goals","text":"<ul> <li>Define policies that apply to multiple <code>Network</code>s simultaneously.</li> </ul>"},{"location":"proposals/10-network-policies/#proposal","title":"Proposal","text":"<p>Introduce a new type <code>NetworkPolicy</code> that regulates traffic within a certain network. By default, traffic to members in a <code>Network</code> is not regulated. However, as soon as a <code>NetworkPolicy</code> selects members of a <code>Network</code>, all ingress and egress traffic concerning the members is denied unless a <code>NetworkPolicy</code> explicitly allows it. This makes it so multiple <code>NetworkPolicy</code> instances can never be in conflict and instead just allow more ingress / egress traffic to be received / sent.</p> <p>Members are selected using a Kubernetes <code>metav1.LabelSelector</code> to allow specifying multiple target network interfaces.</p> <p>A <code>NetworkPolicy</code> specifies rules to treat <code>ingress</code> and <code>egress</code> traffic. To be able to express whether e.g. no <code>ingress</code> or <code>egress</code> traffic is allowed without specifying any rule, <code>NetworkPolicy</code>s always have to specify the <code>policyTypes</code> (either <code>Ingress</code> / <code>Egress</code>) they want to enforce.</p> <p>Example manifest:</p> <pre><code>apiVersion: networking.api.onmetal.de/v1alpha1\nkind: NetworkPolicy\nmetadata:\n  namespace: default\n  name: my-network-policy\nspec:\n  # This specifies the target network to limit the traffic in.\n  networkRef:\n    name: my-network\n  # Only network interfaces in the specified network will be selected.\n  networkInterfaceSelector:\n    matchLabels:\n      app: db\n  # If the policy types are not specified, they are inferred on whether\n  # any ingress / egress rule exists. If no ingress / egress rule exists,\n  # the network policy is denied on admission.\n  policyTypes:\n  - Ingress\n  - Egress\n  # Multiple ingress / egress rules are possible.\n  ingress:\n  - from:\n    # Traffic can be limited from a source IP block.\n    - ipBlock:\n        cidr: 172.17.0.0/16\n    # Traffic can also be limited to objects of the networking api.\n    # For instance, to limit traffic from network interfaces, one could\n    # specify the following:\n    - objectSelector:\n        kind: NetworkInterface\n        matchLabels:\n          app: web\n    # Analogous to network interfaces, it is also possible to limit\n    # traffic coming from load balancers:\n    - objectSelector:\n        kind: LoadBalancer\n        matchLabels:\n          app: web\n    # Ports always have to be specified. Only traffic matching the ports\n    # will be allowed.\n    ports:\n    - protocol: TCP\n      port: 5432\n  egress:\n  - to:\n    - ipBlock:\n        cidr: 10.0.0.0/24\n    ports:\n    - protocol: TCP\n      port: 8080\n</code></pre>"},{"location":"proposals/10-network-policies/#alternatives","title":"Alternatives","text":"<ul> <li>Provide an own networking overlay that enforces the rules. However, this   involves significant effort and maintenance.</li> <li>Have hypervisors / management processes monitor traffic sent by application   processes. However, monitoring of the hypervisors / management processes still   is not addressed with this.</li> </ul>"}]}